<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hin&#39;s 灵质空间</title>
  <icon>https://worranhin.github.io/icon.png</icon>
  
  <link href="https://worranhin.github.io/atom.xml" rel="self"/>
  
  <link href="https://worranhin.github.io/"/>
  <updated>2025-07-08T06:40:16.414Z</updated>
  <id>https://worranhin.github.io/</id>
  
  <author>
    <name>Hin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 WinUI3 应用中使用 Matlab 导出共享库的问题</title>
    <link href="https://worranhin.github.io/2025/06/15/winui-matlab/"/>
    <id>https://worranhin.github.io/2025/06/15/winui-matlab/</id>
    <published>2025-06-15T04:43:40.000Z</published>
    <updated>2025-07-08T06:40:16.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近期，需要为项目写一个集成工业控制上位机软件，其中有一个机器人的运动学逆解依赖了 Matlab 的导出库。基于这个导出库函数包装了一个求解器类，编写单元测试后，实测能正常运行。</p><p>但是在 WinUI3 写的图形界面中引用这个库时，却报出了如下错误：</p><blockquote><p>DllNotFoundException: Unable to load DLL ‘mclmcrrt23_2.dll’ or one of its dependencies: 找不到指定的模块。 (0x8007007E)</p></blockquote><p>很明显，这是找不到 DLL 了，但是经确认这个 dll 是在 Matlab Runtime 安装目录下的一个子目录下，且这个目录也都在系统的 PATH 环境变量中。正常的话不应该会找不到的喵。为了进一步验证，我将这个文件直接丢到运行目录下，同样也是会报出这个错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于这个东西在单元测试都能正常加载，在 WinUI 项目中就不行，这就非常可疑。所以猜测是 WinUI 项目的一些配置问题。所以打开 WinUI 项目的属性，翻阅了一下。发现有个 MSIX Packaging 的选项非常可疑，这个选项默认是启用的状态。我试着把它关闭之后，再编译运行，结果竟然就可以正常运行了。</p><h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><h3 id="MSIX"><a href="#MSIX" class="headerlink" title="MSIX"></a>MSIX</h3><p>要知道这个东西为什么会有影响，那就要先去了解一下，这个 MSIX 是个什么东西。参考<a href="https://learn.microsoft.com/en-us/windows/msix/overview">微软关于 MSIX 的文档</a>，MSIX 就是 Windows 的新一代软件打包格式，具有稳定、快速等这样那样的有点，看上去没什么可疑的地方。但是在文档的 HighLights 下提到了 Package Support Framework(PSF) 用于修复一些运行时问题。那么继续点进这个<a href="https://learn.microsoft.com/en-us/windows/msix/psf/package-support-framework-overview">链接</a>就发现，其中一个问题就是找不到 DLL。</p><blockquote><p>Here are some common examples where you can find the Package Support Framework useful:</p><ul><li>Your app can’t find some DLLs when launched. You may need to set your current working directory. You can learn about the required current working directory in the original shortcut before you converted to MSIX.</li><li>The app writes into the install folder. You will typically see it by “Access Denied” errors in Process Monitor.</li><li>Your app needs to pass parameters to the executable on launch. You can learn more how PSF can help by going here and learn more about the available configurations here.</li></ul></blockquote><p>继续往下看，就会发现这个 PSF 有一个 Dynamic Library Fixup，这似乎就是用于解决找不到 DLL 的问题的。但是，这是真的很麻烦啊，Matlab runtime 有这么多 dll，难道还要一个个去重映射吗。更何况我们的项目确实也没必要使用到 MSIX 喵。所以直接禁用 MSIX 是可行的。</p><p>但说到底，为什么使用 MSIX 会导致如上问题呢。原因似乎是 MSIX 软件会运行在一个类似沙盒的容器中，可能访问不到系统的环境变量 PATH，而导致运行时找不到 MATLAB 所需的 DLL 文件。可以参考这篇帖子：<a href="https://techcommunity.microsoft.com/discussions/msix-discussions/access-sdk-outside-of-msix-application/2039170">Access SDK outside of MSIX application</a>，以及关于打包与不打包的的优缺点的<a href="https://learn.microsoft.com/en-us/windows/apps/package-and-deploy/">文档</a>。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;近期，需要为项目写一个集成工业控制上位机软件，其中有一个机器人的运动学逆解依赖了 Matlab</summary>
        
      
    
    
    
    
    <category term="Matlab" scheme="https://worranhin.github.io/tags/Matlab/"/>
    
    <category term="WinUI3" scheme="https://worranhin.github.io/tags/WinUI3/"/>
    
    <category term="MSIX" scheme="https://worranhin.github.io/tags/MSIX/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中使用 Matlab 导出 Dll 时遇到的一些问题</title>
    <link href="https://worranhin.github.io/2025/05/30/matlab-cpp/"/>
    <id>https://worranhin.github.io/2025/05/30/matlab-cpp/</id>
    <published>2025-05-30T13:54:41.000Z</published>
    <updated>2025-07-08T06:40:16.414Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重构课题组的一些控制代码，有一个机器人的控制涉及到了 Matlab 导出的 C++ 共享库，而配置这个东西真多坑啊，于是有了本文。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>首先要使用 Matlab 共享库的前提条件是要安装对应的 <a href="https://ww2.mathworks.cn/help/compiler/install-the-matlab-runtime.html">Matlab Runtime</a>。</p><p>其次，我手上有的是一个 <code>.h</code> 头文件，一个 <code>.lib</code> 导入库文件，一个 <code>.dll</code> 文件，和一个 <code>.ctf</code> 文件。那么就是常规的那些配置了。配置好包含路径、库路径后编译一下，发现链接有问题，于是根据头文件的提示把 <code>mclmcrrt.lib</code> 也加入进来，链接就没问题了。</p><h2 id="库初始化的问题"><a href="#库初始化的问题" class="headerlink" title="库初始化的问题"></a>库初始化的问题</h2><p>编译和链接都没问题了，那么就开始调试了，下面是一个最小的流程：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">auto</span> ok = <span class="hljs-built_in">mclInitializeApplication</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化 matlab 库</span>    <span class="hljs-keyword">if</span> (!ok)        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Fail to initialize Matlab dll.&quot;</span>);    ok = <span class="hljs-built_in">invPosMainAnyPlace2ndOffsetInitialize</span>();  <span class="hljs-comment">// 初始化自定义库</span>    <span class="hljs-keyword">if</span> (!ok)        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Fail to initialize inv solver lib.&quot;</span>);    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">invPosMainAnyPlace2ndOffset</span>(<span class="hljs-comment">/* 函数的参数 */</span>);  <span class="hljs-comment">// 调用函数</span>    <span class="hljs-comment">// 处理结果</span>    <span class="hljs-built_in">invPosMainAnyPlace2ndOffsetTerminate</span>();  <span class="hljs-comment">// 终止自定义库</span>    ok = <span class="hljs-built_in">mclTerminateApplication</span>();  <span class="hljs-comment">// 终止 matlab 库</span>    <span class="hljs-keyword">if</span> (!ok)        std::cerr &lt;&lt; <span class="hljs-string">&quot;Fail to terminate matlab dll.&quot;</span>;&#125;</code></pre></div><p>然而，运行 <code>invPosMainAnyPlace2ndOffsetInitialize()</code> 的时候返回值为 <code>false</code> 也就是说不能完成用户库的初始化。在网上找了一通没有结果，然后想起还有个 <code>.ctf</code> 文件，于是将他丢到可执行文件下的目录里，欸，然后就好了。</p><h2 id="访问冲突错误"><a href="#访问冲突错误" class="headerlink" title="访问冲突错误"></a>访问冲突错误</h2><p>但是这时候又遇到了另一个问题，那就是在运行 <code>invPosMainAnyPlace2ndOffsetInitialize()</code> 的时候，会报出接连几个访问冲突的错误，像下面这样：</p><blockquote><p>0x000000006C518598 (jvm.dll)处(位于 TestIndustrialController.exe 中)引发的异常: 0xC0000005: 写入位置 0x0000018E77F30580 时发生访问冲突。</p></blockquote><p>但与此同时，初始化的结果又为 <code>true</code> 然后后面的函数功能也正常。另外，如果不开调试模式运行，它也没有什么异常的地方，也不报错了。但是调试的时候就很不方便也很不爽。于是又是上网进行一通查找，最后在一个 <a href="https://cloud.tencent.com/developer/ask/sof/114327358">Stack Overflow 用户</a>找到了解决方法。</p><p>解决的方法就是修改 <code>mclInitializeApplication()</code> 的调用参数，如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* args[] = &#123; <span class="hljs-string">&quot;-nojvm&quot;</span> &#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> count = <span class="hljs-built_in">sizeof</span>(args) / <span class="hljs-built_in">sizeof</span>(args[<span class="hljs-number">0</span>]);<span class="hljs-keyword">auto</span> ok = <span class="hljs-built_in">mclInitializeApplication</span>(args, count);</code></pre></div><p>其实应该就是禁用 jvm 的意思吧。到这里才发现那些个错误大部分都是由 <code>jvm.dll</code> 发出的，也正因此可以通过禁用 jvm 来解决问题。</p><p>然后，我又找到<a href="https://ww2.mathworks.cn/help/compiler_sdk/cxx/mclinitializeapplication.html#mw_c3d0bbd0-f7f9-4775-92b0-0665f81359cc">这个函数的文档</a>看了一下，它的声明如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mclInitializeApplication</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **options, <span class="hljs-type">int</span> count)</span></span></code></pre></div><p>其中第一个参数是 C 风格的字符串数组，第二个参数是数组的大小，也就是说，上面提到的解决方案的第二个参数应该为 <code>1</code> 才对，于是修改如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* args[] = &#123; <span class="hljs-string">&quot;-nojvm&quot;</span> &#125;;<span class="hljs-keyword">auto</span> ok = <span class="hljs-built_in">mclInitializeApplication</span>(args, <span class="hljs-number">1</span>);</code></pre></div><p>经测试，修改后的代码也没有问题，但是更严谨，免得后面又出什么问题。不过奇怪的是，在文档中指出，<code>-nojvm</code> 在 Linux 平台有效，但我明明是在 Windows 10 和 Visual Studio 2022 上跑的，这个选项却也生效了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Whatever，至此问题都处理完了。下班！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近在重构课题组的一些控制代码，有一个机器人的控制涉及到了 Matlab 导出的 C++ 共享库，而配置这个东西真多坑啊，于是有了本文。&lt;/p&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="cpp" scheme="https://worranhin.github.io/tags/cpp/"/>
    
    <category term="DLL" scheme="https://worranhin.github.io/tags/DLL/"/>
    
    <category term="Matlab" scheme="https://worranhin.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>在微信部署 AI 助手 [未完成]</title>
    <link href="https://worranhin.github.io/2025/03/20/chatgpt-on-wechat/"/>
    <id>https://worranhin.github.io/2025/03/20/chatgpt-on-wechat/</id>
    <published>2025-03-20T05:31:08.000Z</published>
    <updated>2025-07-08T06:40:16.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一个在微信里使用 chatgpt 的<a href="https://github.com/zhayujie/chatgpt-on-wechat">Github 开源项目</a>，于是想试一试。</p><p>首先是先按照文档中快速开始的流程过了一遍，发现现在微信已经不支持个人微信搞这个了，只能用公众号或企业号那些整这个。</p><p>于是想着来都来了，就整个公众号玩玩吧。就注册了个公众号。结果发现在公众号上跑，需要有个服务器。这可怎么办呢。本着能白嫖就不花钱的原则，找了一圈，发现微软的 Azure 有个学生认证，可以在一年内使用 100 美元的额度。那么我立即认证，折腾了一下，就得到了一个低配 Ubuntu 虚拟机了。</p><p>接下来就是欢喜地在服务器上装个环境，然后开跑快速开始。结果在微信公众号平台填写服务器配置的时候出了问题，不管怎样，它都弹出“参数错误，请重新填写”的错误。于是去网上搜索了一番，看到这个<a href="https://developers.weixin.qq.com/community/develop/doc/000402c01cc7a0f7d1f9c7fd651800">帖子</a>，下面有人说可以在微信打开域名检查一下是否出现已停止访问该页面的警告。那么我快速尝试后发现，还真是。那就是说白嫖的服务器 ip 被微信屏蔽了咯。真是可恶啊，还整得挺安全的。那后面只能看看能不能申诉一下了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近看到一个在微信里使用 chatgpt 的&lt;a href=&quot;https://github.com/zhayujie/chatgpt-on-wechat&quot;&gt;Github</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MuJoCo 踩坑日志</title>
    <link href="https://worranhin.github.io/2025/03/04/mujoco/"/>
    <id>https://worranhin.github.io/2025/03/04/mujoco/</id>
    <published>2025-03-04T06:03:46.000Z</published>
    <updated>2025-07-08T06:40:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 MuJoCo 仿真环境，决定在此记录下踩下的坑。</p><span id="more"></span><h2 id="抽搐的关节"><a href="#抽搐的关节" class="headerlink" title="抽搐的关节"></a>抽搐的关节</h2><p>在搭建 MuJoCo 仿真环境时发现添加关节后，它一直在抽搐，开始以为是摩擦、阻尼之类的没设好，问 copilot 也是建议去设置一下相关的参数。</p><blockquote><p>Copilot 是这么说的：<br>你的 robot_r1 关节一直在旋转，可能是因为缺少摩擦力或阻尼，导致关节在仿真中无法稳定下来。你可以尝试增加关节的摩擦力或调整阻尼参数来解决这个问题 …</p></blockquote><p>然而设置并调整了也没什么用。然后在 MuJoCo 的图形界面一番摸索后发现一些端倪。</p><p><img src="/2025/03/04/mujoco/image1.png" alt="MuJoCo Simulate 界面"></p><p>如上图所示，我打开了 Convex Hull 选项，看到外面的框架的凸包，于是我开始怀疑是碰撞的问题，于是将抽搐的关节移出整个框架外，果然就不抽搐了。那接下来就是修改碰撞检测的问题了。</p><p>翻看文档，有这么两个参数：</p><blockquote><p>contype: int, “1”<br>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p></blockquote><blockquote><p>conaffinity: int, “1”<br>Bitmask for contact filtering; see contype above.</p></blockquote><p><del>那么就把这个外框架的两个参数都设为 2 好了，其它的默认为 1 保持不变。</del></p><p>在 v3.2.5 版本时，如果都设为 0 的话就会闪退，不知道为什么。但是升级到 v3.3.0 版本后就不会了，所以按道理就是把这两个参数都设为零，就是不会检测碰撞了！</p><blockquote><p>需要注意的是，这个参数是 bitmasks 的形式，也就是说设为 3(0b0011) 的话，也是会和默认的 1(ob0001) 发生碰撞的。</p></blockquote><h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><p>其实跟上面提到的问题类似，其它的一些需要较高精度的物体，MuJoCo 默认只能将它们处理为凸包来实现碰撞检测，这就导致一些物体很难直接得到真实的仿真效果，而最显而易见的就是轴孔装配（Peg-in-hole）的问题了。</p><blockquote><p>官方文档的介绍：<a href="https://mujoco.readthedocs.io/en/stable/computation/index.html#geom-distance">链接</a></p></blockquote><p>不妙的是，我正正是需要仿真一个类似轴孔装配的情况。如<a href="https://github.com/google-deepmind/mujoco/discussions/738?sort=old">这篇讨论</a>所述，要处理这个问题，目前只能去做一个凸包分解的工作，而好消息是，有现成的算法和工具去做这个事情。</p><p>正如帖子中提到的，有一个叫做 <a href="https://github.com/kevinzakka/obj2mjcf">obj2mjcf</a> 的工具可以自动将 obj 文件分解成多个凸包，并生成对应的 mjcf xml 文件。那么现在的问题就变成了，我要怎么从 solidworks 模型得到 obj 格式的文件了。解决方法也很简单，就是整个 Blender 软件，导入 stl，导出 obj，结束。<del>就是这么简单而又粗暴。</del></p><p>具体的使用就不赘述了，不过就是有个小坑。不知道为什么有时用 Blender 导出的 obj 文件，在 obj2mjcf 处理的时候会报错，如下：</p><div class="code-wrapper"><pre><code class="hljs shell">Traceback (most recent call last):  File &quot;D:\Program Files\python3\lib\runpy.py&quot;, line 196, in _run_module_as_main    return _run_code(code, main_globals, None,  File &quot;D:\Program Files\python3\lib\runpy.py&quot;, line 86, in _run_code    exec(code, run_globals)  File &quot;D:\Program Files\python3\Scripts\obj2mjcf.exe\__main__.py&quot;, line 7, in &lt;module&gt;  File &quot;D:\Program Files\python3\lib\site-packages\obj2mjcf\cli.py&quot;, line 280, in main    process_obj(obj_file, args)  File &quot;D:\Program Files\python3\lib\site-packages\obj2mjcf\cli.py&quot;, line 138, in process_obj    for line in f.readlines():UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0xb9 in position 64: illegal multibyte sequence</code></pre></div><p>不过按下面的配置导出，且不保存 Blender 文件的话，就可以正常运行，可以稍微参考一下：</p><p><img src="/2025/03/04/mujoco/image2.png" alt="导出 obj 配置项"></p><h2 id="微小零件的穿模问题"><a href="#微小零件的穿模问题" class="headerlink" title="微小零件的穿模问题"></a>微小零件的穿模问题</h2><p>继续添加一个自由的物体，发现它并没有按预期地被另一个固定的物体兜住，就像是直接穿模了一般掉到了地上。这真是太怪了。</p><p><del>最后发现是 timestep 设太高了，而且初始位置太高，导致加速度有点大，托不住。（后来发现并不是这个问题，而是需要设置 solimp 和 solref 的参数）</del></p><p>为了解决这个问题，需要去设置 MuJoCo 的 <a href="https://mujoco.readthedocs.io/en/stable/modeling.html#solver-parameters">Solver Parameters</a>这些参数决定了 MuJoCo 仿真器的接触约束行为。</p><p>在 MuJoCo 中，约束空间的动力学可以近似为下面的形式：</p><p>$$a_1 + d (bv+kr) &#x3D; (1-d) a_0$$</p><p>将上式移一下项，意义会更清晰：</p><p>$$a_1 &#x3D; (1-d) \cdot a_0 + d \cdot (-bv-kr)&#x3D; (1-d) \cdot a_0 + d \cdot a_{ref}$$</p><p>其中，$k$ 为刚度（stiffness）, $b$ 为阻尼系数（damping）, $d$ 为阻抗系数（Impedance）。$a_1$ 为末状态加速度，$a_0$ 为原加速度，$a_{ref}$ 为参考加速度。$v$ 为速度，$r$ 为渗透深度。上式也就是说约束状态下的加速度等于无约束状态下的加速度与参考加速度的加权平均。</p><p>而 Sover parameters 的设置由两部分组成——Impedance 和 Reference，分别对应着 $(k,b)$ 和 $d$ 的行为。</p><h3 id="Impedance"><a href="#Impedance" class="headerlink" title="Impedance"></a>Impedance</h3><p>Impdance 对应着 mjcf 文件中 geom 的 solimp 属性。格式为：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">geom</span> <span class="hljs-attr">solimp</span>=<span class="hljs-string">&quot;0.9 0.05 0.001 0.5 2&quot;</span>&gt;</span></code></pre></div><p>五个参数分别对应 $d_0, d_{\mathrm{width}}, \mathrm{width}, \mathrm{midpoint}, \mathrm{power}$</p><p>这五个参数共同定义了 d 关于 r 的函数：</p><p>$$d(0) &#x3D; d_0, \quad d(\mathrm{width}) &#x3D; d_{\mathrm{width}}$$</p><p>函数图像与各参数的关系示意如下：</p><p><img src="https://mujoco.readthedocs.io/en/stable/_images/impedance.png" alt="不同参数下的d(r)函数图像"></p><p>而关于 d 对接触行为的影响，官方的说法是对应着约束产生力的能力（ability to generate force）。简单来说，d 越大，约束能力越强。举两个极端的例子，若 $d&#x3D;0$ 的话，则表现为没有约束，$a_1 \equiv a_0$；而如果 $d&#x3D;1$ 的话，$a_1 \equiv a_{ref}$，即接触行为只跟相对位置速度关系有关，加速度的变化在一瞬间完成。</p><p>然而上面仅仅是举例，事实上，MuJoCo 中 d 的取值范围是 $[0.0001, 0.9999]$</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Reference 指的是 reference acceleration ($a_{ref}$)，这部分控制参考加速度。它决定了约束试图实现的动作（motion that constraint is trying to achieve）。</p><p>它的设置通过 solref 参数进行：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">geom</span> <span class="hljs-attr">solref</span>=<span class="hljs-string">&quot;0.02 1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">geom</span> <span class="hljs-attr">solref</span>=<span class="hljs-string">&quot;-10 -1&quot;</span>&gt;</span></code></pre></div><p>值得注意的是，这个参数的设置有两种形式，若设置的两个值为正数，则分别代表着时间常数（timeconst）和阻尼比（damp ratio）；若两个值为负数，则其绝对值代表刚度（stiffness）和阻尼（damping）。</p><p>若设置时间常数和阻尼比的话，会在一定的缩放操作后按照质量-弹簧-阻尼器模型来计算出 k 和 b 的值，如下：</p><p>$$b &#x3D; 2 &#x2F; (d_{\mathrm{width}} \cdot timeconst)$$$$k &#x3D; d(r) &#x2F; (d_{\mathrm{width}}^2 \cdot timeconst^2 \cdot dampratio^2)$$</p><p>需要注意，时间常数的值需要至少为模拟器的 timestep 参数的两倍大，否则系统可能会变得过于僵硬。而阻尼比的话一般设为 1，对应着临界阻尼。而小于 1 对应欠阻尼。大于 1 对应过阻尼。</p><blockquote><p>什么是临界阻尼、欠阻尼和过阻尼可自行搜索或参考<a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E5%B0%BC#%E7%B3%BB%E7%BB%9F%E8%A1%8C%E4%B8%BA">百科</a></p></blockquote><p>最重要的一点来了，也是解决本节提出问题的关键。因为约束状态下的加速度等于原加速度（无约束状态下的加速度）与参考加速度的加权平均，而这两个加速度一般是反向的，那么两个准静态接触的物体总会平衡在某个渗透深度下，而这个深度可以推导出来，其结果为：</p><p>$$r &#x3D; a_0 \cdot (1 - d) \cdot timeconst^2 \cdot dampratio^2$$</p><p><strong>而如果这个平衡渗透深度比物体的厚度还要大，那么就势必会穿模啦！</strong> 我的解决方法在下面总结处阐述，现在把这节收尾先。</p><p>正如上面提到的，除了设置时间常数和阻尼比外，还可以直接设置刚度和阻尼，但其实也会做一个缩放操作，如下：</p><p>$$b &#x3D; damping &#x2F; d_{width}$$</p><p>$$k &#x3D; stiffness \cdot d(r) &#x2F; d_{width}^2$$</p><p>而渗透深度如下：</p><p>$$r &#x3D; \frac{a_0 (1-d)}{stiffness}$$</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>那么知道原因后，解决方法也很明显了，通过改变各个参数，令 r 的值远小于物体的厚度即可。我的做法是设置 solimp 的前两个参数为一样的，令 d 为常数。然后保持 dampratio 为 1，将零件最小厚度的 1&#x2F;10 代入 r 中，即可算出 timeconst 的值了。然后验证一下，是否大于 timestep 的两倍，如果不是，则需要减小 timestep 的值了。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">geom</span> <span class="hljs-attr">friction</span>=<span class="hljs-string">&quot;1 0.005 0.01&quot;</span> <span class="hljs-attr">solimp</span>=<span class="hljs-string">&quot;0.99 0.99 0.001 0.1 2&quot;</span> <span class="hljs-attr">solref</span>=<span class="hljs-string">&quot;0.0014 1&quot;</span> <span class="hljs-attr">priority</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span></code></pre></div><p>这里还有一点需要注意的是优先级的问题，即上面的 priority 属性。接触的两个物体优先级不一样，那么就会采用高者数据设置；而如果优先级一样则会计算一次加权平均，权重由 <code>solmix</code> 参数决定。（见<a href="https://mujoco.readthedocs.io/en/stable/modeling.html#contact-parameters">这里</a>）</p><h2 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h2><blockquote><p>参考这个帖子：<a href="https://github.com/google-deepmind/mujoco/issues/175">https://github.com/google-deepmind/mujoco/issues/175</a></p></blockquote><p>一个 Collaborator 给出了解决方案：</p><blockquote><p>You don’t need the callbacks. Just use a high gain position actuator on a joint with enough damping.</p></blockquote><p>也就是说使用一个高 kp 和足够 kv 的一个位置定位 shortcut ：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">position</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stepper&quot;</span> <span class="hljs-attr">joint</span>=<span class="hljs-string">&quot;slider&quot;</span> <span class="hljs-attr">kp</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">kv</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">inheritrange</span>=<span class="hljs-string">&quot;0.8&quot;</span> /&gt;</span></code></pre></div><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这篇文章可能持续更新，敬请期待。</p><blockquote><p>感觉 MuJoCo 的中文教程&#x2F;资料好少啊，而且官方文档写得有点太详细了。其实有点想法写一个简明入门指南，不过，再说吧。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在搞 MuJoCo 仿真环境，决定在此记录下踩下的坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://worranhin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>评论功能，开！</title>
    <link href="https://worranhin.github.io/2025/03/03/comment-on/"/>
    <id>https://worranhin.github.io/2025/03/03/comment-on/</id>
    <published>2025-03-03T07:58:08.000Z</published>
    <updated>2025-07-08T06:40:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>借助 <a href="https://waline.js.org/">waline</a> 的力量，本站的评论功能盛大开幕！</p><p>开启的流程很顺畅，waline 的教程很详尽。总之就是注册了个 LeanCloud 国际版，使用免费的开发版 API，再通过 Vercel 部署 Serverless 服务，就可以啦。</p><p>同时因为 Fluid 内置有这个功能，只要再配置文件上配一配就好了，文档上都有。然后反正都用上 LeanCloud 了，顺便也把浏览量计数 (PV, UV) 给开了。</p><blockquote><p>这下知道到底有没有人看我写的东西了</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;借助 &lt;a href=&quot;https://waline.js.org/&quot;&gt;waline&lt;/a&gt; 的力量，本站的评论功能盛大开幕！&lt;/p&gt;
&lt;p&gt;开启的流程很顺畅，waline 的教程很详尽。总之就是注册了个 LeanCloud 国际版，使用免费的开发版 API，再通过</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>局域网设备访问 V2rayN 代理</title>
    <link href="https://worranhin.github.io/2025/02/26/v2rayn/"/>
    <id>https://worranhin.github.io/2025/02/26/v2rayn/</id>
    <published>2025-02-26T11:04:56.000Z</published>
    <updated>2025-07-08T06:40:16.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>近期有使用热点连接 V2rayN 代理的需求，于是参考网上的帖子设置了 V2rayN 允许局域网访问，也配置了从设备的代理，但是发现却连不了网。</p><p>进一步搜索资料发现跟防火墙设置有关，部分教程表示需要关掉防火墙或者做额外的设置，但没找到要怎么做相关的配置。</p><p>首先是先试试关掉防火墙，实测发现只要关掉公共网络的防火墙，从设备即可正常访问了。但是感觉直接关掉防火墙不太好，于是摸索了下配置例外程序的方法。</p><p>在防火墙配置页面上能看到<code>允许应用通过防火墙</code>的设置，点进该设置，然后把 v2rayN的专用和公用都勾选上试了试，发现还是不行。</p><p><img src="/2025/02/26/v2rayn/image-0.png" alt="防火墙配置页面"></p><p><img src="/2025/02/26/v2rayn/image.png" alt="允许应用通过防火墙配置页面"></p><p>接着在刚刚的页面点进高级设置里看了看，发现里面的入站规则也是有 v2rayN 的，但如果将规则按程序排序，就会发现，在同一个目录下除了 v2rayN 还有 sing-box。那么双击选择这些规则，在高级选项卡中把所有配置文件都勾选上。这样再用从设备联网，就发现可以正常上网了。</p><p><img src="/2025/02/26/v2rayn/image-1.png" alt="alt text"></p><p><img src="/2025/02/26/v2rayn/image-2.png" alt="alt text"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，应该就是需要把使用的 v2rayN 应用和它配套的 sing-box 应用在专用网络和公用网络下都允许通过防火墙就可以了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;近期有使用热点连接 V2rayN 代理的需求，于是参考网上的帖子设置了 V2rayN</summary>
        
      
    
    
    
    
    <category term="工具" scheme="https://worranhin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>在 C# 中 Debug C++ Dll</title>
    <link href="https://worranhin.github.io/2024/12/17/debug-dll/"/>
    <id>https://worranhin.github.io/2024/12/17/debug-dll/</id>
    <published>2024-12-17T13:57:39.000Z</published>
    <updated>2025-07-08T06:40:16.410Z</updated>
    
    <content type="html"><![CDATA[<p>现需要调试 dll, 遂在 visual studio 中设置 c++ dll 的断点，然警告称没有加载符号，故上网查找，发现<a href="https://learn.microsoft.com/en-us/visualstudio/debugger/debugging-dll-projects?view=vs-2022">一微软文档</a>和<a href="https://stackoverflow.com/questions/1062910/debug-c-dll-in-c-sharp">一 stackoverflow 帖子</a>，总结步骤如下：</p><ol><li>右击 C++ DLL project, 选择属性 -&gt; 链接器 -&gt; 调试 -&gt; 可调试程序集 -&gt; Yes </li><li>右击 C# 项目，选择属性 -&gt; 调试 -&gt; 打开调试启动配置文件 UI -&gt; 勾选<code>启用本机代码调试</code></li></ol><p>这样就可以了喵。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;现需要调试 dll, 遂在 visual studio 中设置 c++ dll 的断点，然警告称没有加载符号，故上网查找，发现&lt;a</summary>
        
      
    
    
    
    
    <category term="cpp" scheme="https://worranhin.github.io/tags/cpp/"/>
    
    <category term="C#" scheme="https://worranhin.github.io/tags/C/"/>
    
    <category term="DLL" scheme="https://worranhin.github.io/tags/DLL/"/>
    
    <category term="Visual Studio" scheme="https://worranhin.github.io/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Stm32-Ethercat 主站开发日志</title>
    <link href="https://worranhin.github.io/2024/11/30/stm32-ethercat/"/>
    <id>https://worranhin.github.io/2024/11/30/stm32-ethercat/</id>
    <published>2024-11-30T14:35:19.000Z</published>
    <updated>2025-07-08T06:40:16.413Z</updated>
    
    <content type="html"><![CDATA[<p>在此姑且用流水账的形式记录一下用 STM32 开发 Ethercat 主站时遇到的重重困难。</p><h2 id="开发板硬件配置"><a href="#开发板硬件配置" class="headerlink" title="开发板硬件配置"></a>开发板硬件配置</h2><p>开发板使用的是 STM32F407ZGT6.</p><h3 id="网络模块-ETH"><a href="#网络模块-ETH" class="headerlink" title="网络模块 ETH"></a>网络模块 ETH</h3><p>买的开发板的使用了 25MHz 的无源晶振作为 LAN8720A 的时钟输入，将 REF_CLK 配置为 Out Mode，即 REF_CLK 引脚为 50MHz 时钟的输出，将该引脚接到 STM32 上的对应引脚上即可同步二者的时钟。</p><h2 id="电脑网络配置"><a href="#电脑网络配置" class="headerlink" title="电脑网络配置"></a>电脑网络配置</h2><p>在调试 LwIP 时使用电脑直接插网线到开发板上，开发板上加载了示例的 tcp_echo_server 程序，也就是开发板作为 tcp 协议的服务器，但是电脑的调试工具一直连不上，感到很奇怪。在不断检查代码然无果后，突然想到改一下电脑网卡的 IP 试试，改了之后果然就可以了。这可能是因为电脑用的是工位的固定 IP 地址，也不知道是不是这个原因。还是要再补充一点计算机网络的知识啊。</p><blockquote><p>在这里顺便安利一下在微软应用商店找到的一个网络调试工具，叫做 TCPUDP网络调试助手，界面是用 WinUI3 编写的，非常现代简洁好看，很符合我的 xp</p></blockquote><h2 id="应用-FreeRTOS"><a href="#应用-FreeRTOS" class="headerlink" title="应用 FreeRTOS"></a>应用 FreeRTOS</h2><p>在成功用电脑 ping 通板子后，开始学习 FreeRTOS 的使用，首先是在 CubeMX 中启动，并且在 SYS 中设置 Timebase, 这里就设为基本定时器 TIM6 吧，接着按照提示在 FreeRTOS 的 Advanced Settings 选项将 USE_NEWLIB_REENTRANT 设为 Enable, 因为这个应用应该比较简单，所以暂时就将 Memory Management scheme 设置为 <code>heap_1</code>, 即内存一旦分配就不再解除的模式。然后看了看芯片数据手册，是支持 FPU 的，所以把 <code>ENABLE_FPU</code> 也设置上。那差不多就可以保存一下，生成代码了。</p><blockquote><p>在生成代码后记得改一下 ethernetif.c, 因为开发板用的不是 lan8742 而是 lan8720</p></blockquote><p>在用 FreeRTOS 时遇到一个问题，程序会停在这个地方：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Look up the interrupt&#x27;s priority. */</span>ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];<span class="hljs-comment">/* The following assertion will fail if a service routine (ISR) for</span><span class="hljs-comment">an interrupt that has been assigned a priority above</span><span class="hljs-comment">configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API</span><span class="hljs-comment">function.  ISR safe FreeRTOS API functions must *only* be called</span><span class="hljs-comment">from interrupts that have been assigned a priority at or below</span><span class="hljs-comment">configMAX_SYSCALL_INTERRUPT_PRIORITY.</span><span class="hljs-comment"></span><span class="hljs-comment">Numerically low interrupt priority numbers represent logically high</span><span class="hljs-comment">interrupt priorities, therefore the priority of the interrupt must</span><span class="hljs-comment">be set to a value equal to or numerically *higher* than</span><span class="hljs-comment">configMAX_SYSCALL_INTERRUPT_PRIORITY.</span><span class="hljs-comment"></span><span class="hljs-comment">Interrupts thatuse the FreeRTOS API must not be left at their</span><span class="hljs-comment">default priority ofzero as that is the highest possible priority,</span><span class="hljs-comment">which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,</span><span class="hljs-comment">andtherefore also guaranteed to be invalid.</span><span class="hljs-comment"></span><span class="hljs-comment">FreeRTOS maintains separate thread and ISR API functions to ensure</span><span class="hljs-comment">interrupt entry is as fast and simple as possible.</span><span class="hljs-comment"></span><span class="hljs-comment">The following links provide detailed information:</span><span class="hljs-comment">http://www.freertos.org/RTOS-Cortex-M3-M4.html</span><span class="hljs-comment">http://www.freertos.org/FAQHelp.html */</span>configASSERT( ucCurrentPriority &gt;= ucMaxSysCallPriority );</code></pre></div><p>按它的说法，就是系统中断的优先级不能设得比 configMAX_SYSCALL_INTERRUPT_PRIORITY 高（数值更低），那让我试试把它改小吧。</p><p>好了，这个问题解决了，但是总是跳到 <code>Hard_Fault_Handler()</code> 。</p><p>于是上网找了找官方的LwIP示例，找了一通发现原来是 FreeRTOS 的 defaultThread也就是 LwIP 的线程给的 Stack size 太小了，默认只有 128，但是官方给的是 512 * 4，差的也太多了。</p><p>仔细看了看 LwIP 模块有个配置项叫 <code>DEFAULT_THREAD_STACKSIZE</code>, 默认为 1024，可能是要比这个大吧。</p><p>姑且先改为 2048 吧，这样系统就正常运行了。</p><h3 id="TCP-UDP-with-RTOS-测试"><a href="#TCP-UDP-with-RTOS-测试" class="headerlink" title="TCP&#x2F;UDP with RTOS 测试"></a>TCP&#x2F;UDP with RTOS 测试</h3><p>接着试一试示例里 TCPUDP with RTOS 的代码吧，直接把 tcpecho 的代码 copy 进来，在 main 中的 StartDefaultThread 里面初始化，然后在电脑上发一个消息，结果是成功地返回了。</p><p>然后再试试 UDP, 同样地，把代码 copy 进来再做一些小修改，结果就跑不动了。</p><p>经过一番调试，最后是定位到这个 ASSERT 中：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* A function that implements a task must not exit or attempt to return to</span><span class="hljs-comment">its caller as there is nothing to return to.  If a task wants to exit it</span><span class="hljs-comment">should instead call vTaskDelete( NULL ).</span><span class="hljs-comment"></span><span class="hljs-comment">Artificially force an assert() to be triggered if configASSERT() is</span><span class="hljs-comment">defined, then stop here so application writers can catch the error. */</span>configASSERT( uxCriticalNesting == ~<span class="hljs-number">0UL</span> );</code></pre></div><p>他说线程中不应该有返回，但是我也没有返回啊，于是去问问 Kimi, 他给我翻译了一遍，然后说可能是栈空间不足，可以尝试增加任务的栈大小。欸，貌似似曾相识的问题。于是去到 FreeRTOS 的配置中，增大了 <code>TOTAL_HEAP_SIZE</code>, 然后就可以了…… 还真是这个问题啊。看来以后遇到奇怪的错误还是优先检查一下分配的栈空间够不够吧（或者直接一步到位分到最大值，但隐约感觉这样不太好）</p><blockquote><p>顺带一提，现在的 <code>TOTAL_HEAP_SIZE</code> 是 20480 Bytes(20KB), 之前的话是 15360 Bytes(15KB), 也就差了 5KB 嘛 (ﾟ∀。), 这样一看还是增到原来的两倍得了，也就是 30720 Bytes, 反正最大支持 128KB 呢 ( &#96; ・´)</p></blockquote><p>嗯……现在还有个奇怪的问题，就是复位之后如果在短时间内给板子发信息，就会出错，程序就不跑了（用定时器写了个LED 1s 闪烁的程序，但是 LED 也不闪了）。但是如果过一定时间再发，好像就没有这个问题，很奇怪，难道要在某个地方加个延时吗？</p><h2 id="SOEM-移植"><a href="#SOEM-移植" class="headerlink" title="SOEM 移植"></a>SOEM 移植</h2><p>接下来就是 SOEM 的移植工作了，看到一个挺不错的<a href="https://blog.csdn.net/pengrunxin/article/details/127202794">文章</a>，甚至也是控制汇川的，先参考参考。<a href="https://club.rt-thread.org/ask/article/59c34adc09b75123.html">这篇帖子</a>是用 RT-Thread 实现主站控制汇川电机，但没有开放源码，也能稍作参考。</p><p>移植列表 (osal.c)  </p><ul><li><input checked="" disabled="" type="checkbox"> void osal_timer_start(osal_timert * self, uint32 timeout_us);</li><li><input checked="" disabled="" type="checkbox"> boolean osal_timer_is_expired(osal_timert * self);</li><li><input checked="" disabled="" type="checkbox"> int osal_usleep(uint32 usec);</li><li><input checked="" disabled="" type="checkbox"> ec_timet osal_current_time(void);</li><li><input checked="" disabled="" type="checkbox"> void osal_time_diff(ec_timet *start, ec_timet *end, ec_timet *diff);</li><li><input checked="" disabled="" type="checkbox"> int osal_thread_create(void *thandle, int stacksize, void *func, void *param);</li><li><input checked="" disabled="" type="checkbox"> int osal_thread_create_rt(void *thandle, int stacksize, void *func, void *param);</li></ul><p>OK, osal.c 文件移植完成，接下来是 oshw 目录下的 nicdrv(NIC driver) 和 oshw(OS hardware)</p><p>oshw.c: </p><ul><li><input checked="" disabled="" type="checkbox"> uint16 oshw_htons(uint16 host);</li><li><input checked="" disabled="" type="checkbox"> uint16 oshw_ntohs(uint16 network);</li><li><input checked="" disabled="" type="checkbox"> ec_adaptert * oshw_find_adapters(void);</li><li><input checked="" disabled="" type="checkbox"> void oshw_free_adapters(ec_adaptert * adapter);</li></ul><p>nicdrv.c:</p><ul><li><input checked="" disabled="" type="checkbox"> void ec_setupheader(void *p);</li><li><input checked="" disabled="" type="checkbox"> int ecx_setupnic(ecx_portt *port, const char * ifname, int secondary);      &#x2F;&#x2F;网口初始化并打开</li><li><input checked="" disabled="" type="checkbox"> int ecx_closenic(ecx_portt *port);                                           &#x2F;&#x2F;网口关闭</li><li><input checked="" disabled="" type="checkbox"> void ecx_setbufstat(ecx_portt *port, int idx, int bufstat);                 &#x2F;&#x2F;设置idx号缓冲区状</li><li><input checked="" disabled="" type="checkbox"> int ecx_getindex(ecx_portt *port);                                           &#x2F;&#x2F;获取空闲idx缓冲区号获取新的帧标识符索引并分配相应的缓冲区.</li><li><input checked="" disabled="" type="checkbox"> int ecx_outframe(ecx_portt *port, int idx, int stacknumber);                &#x2F;&#x2F;发送数据</li><li><input checked="" disabled="" type="checkbox"> int ecx_outframe_red(ecx_portt *port, int idx);                             &#x2F;&#x2F;通过次口发送数据</li><li><input checked="" disabled="" type="checkbox"> int ecx_waitinframe(ecx_portt *port, int idx, int timeout);                 &#x2F;&#x2F;等待idx号返回并接收 接收数据函数</li><li><input checked="" disabled="" type="checkbox"> int ecx_srconfirm(ecx_portt *port, int idx,int timeout);                    &#x2F;&#x2F;发送idx 并等待接收数据的函数</li></ul><p>en… 偶然间看到这个：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ethercattype.h</span><span class="hljs-comment">// ...</span><span class="hljs-comment">/** define EC_VER1 if version 1 default context and functions are needed</span><span class="hljs-comment"> * comment if application uses only ecx_ functions and own context */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EC_VER1</span></code></pre></div><p>以及这一段：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// nicdrv.h</span><span class="hljs-comment">// ...</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EC_VER1</span><span class="hljs-keyword">extern</span> ecx_portt     ecx_port;<span class="hljs-keyword">extern</span> ecx_redportt  ecx_redport;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_setupnic</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * ifname, <span class="hljs-type">int</span> secondary)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_closenic</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">ec_setbufstat</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> bufstat)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_getindex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_outframe</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> stacknumber)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_outframe_red</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_waitinframe</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> timeout)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">ec_srconfirm</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> timeout)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>那我果断注释掉，又可以少移植一部分。还有我发现其实这两个模块的代码貌似在主要模块 soem 中也不怎么用到，原来还以为是主模块依赖这两个模块，所以统一接口方便移植呢，现在看来，嗯……不太懂了</p><h2 id="硬件初始化问题"><a href="#硬件初始化问题" class="headerlink" title="硬件初始化问题"></a>硬件初始化问题</h2><p>在测试 ETH 模块时又遇到一个很奇怪的问题，就是下面这段代码，本应该是会 Start ETH 模块才对，但调试了几次，感觉它根本就没有进到这一步，而且是单步执行的时候，可以正常运行，但直接连续运行的时候就不行。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ETH_StartLink</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  ETH_MACConfigTypeDef MACConf = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-type">int32_t</span> PHYLinkState = <span class="hljs-number">0U</span>;  <span class="hljs-type">uint32_t</span> linkchanged = <span class="hljs-number">0U</span>, speed = <span class="hljs-number">0U</span>, duplex =<span class="hljs-number">0U</span>;  PHYLinkState = LAN8720_GetLinkState(&amp;lan8720);  <span class="hljs-keyword">if</span>(PHYLinkState &lt;= LAN8720_STATUS_LINK_DOWN)  &#123;    HAL_ETH_Stop(&amp;heth);  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(PHYLinkState &gt; LAN8720_STATUS_LINK_DOWN)  &#123;    <span class="hljs-keyword">switch</span> (PHYLinkState)    &#123;    <span class="hljs-keyword">case</span> LAN8720_STATUS_100MBITS_FULLDUPLEX:      duplex = ETH_FULLDUPLEX_MODE;      speed = ETH_SPEED_100M;      linkchanged = <span class="hljs-number">1</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LAN8720_STATUS_100MBITS_HALFDUPLEX:      duplex = ETH_HALFDUPLEX_MODE;      speed = ETH_SPEED_100M;      linkchanged = <span class="hljs-number">1</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LAN8720_STATUS_10MBITS_FULLDUPLEX:      duplex = ETH_FULLDUPLEX_MODE;      speed = ETH_SPEED_10M;      linkchanged = <span class="hljs-number">1</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> LAN8720_STATUS_10MBITS_HALFDUPLEX:      duplex = ETH_HALFDUPLEX_MODE;      speed = ETH_SPEED_10M;      linkchanged = <span class="hljs-number">1</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span>(linkchanged)    &#123;      HAL_ETH_GetMACConfig(&amp;heth, &amp;MACConf);      MACConf.DuplexMode = duplex;      MACConf.Speed = speed;      MACConf.DropTCPIPChecksumErrorPacket = DISABLE;      MACConf.ForwardRxUndersizedGoodPacket = ENABLE;      HAL_ETH_SetMACConfig(&amp;heth, &amp;MACConf);      HAL_ETH_Start_IT(&amp;heth);      &#125;  &#125;&#125;</code></pre></div><p>这时我也想到是某个地方可能需要等待一下初始化之类的，但就是没找到。在数次尝试后，才想起来给 <code>PHYLinkState &lt;= LAN8720_STATUS_LINK_DOWN</code> 这个判断里面打个断点。果然就是连续运行就会进到这一步，单步执行就会执行下面的正常的 Start 代码。那看来是 PHY 外设的初始化需要一点时间。那接下来就是看看 LAN8720 的数据手册看看能不能加点判断，或者加一个延时暴力解决吧。</p><p>简单查找，发现 <em>PHY SPECIAL CONTROL&#x2F;STATUS REGISTER</em> 寄存器中有这样一位：</p><blockquote><p>Autodone: bit 12<br>Auto-negotiation done indication:<br>0 &#x3D; Auto-negotiation is not done or disabled (or not active)<br>1 &#x3D; Auto-negotiation is done  </p></blockquote><p>那么就通过一个 while 循环判断这一位的值来确保 auto-negotiation 的完成吧：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;    pObj-&gt;IO.ReadReg(addr, LAN8720_PHYSCSR, &amp;regvalue);&#125; <span class="hljs-keyword">while</span>((regvalue &amp; LAN8720_PHYSCSR_AUTONEGO_DONE) != LAN8720_PHYSCSR_AUTONEGO_DONE); <span class="hljs-comment">// 等待 auto-negotiation 完成</span></code></pre></div><h2 id="结合-FreeRTOS-与-ETH"><a href="#结合-FreeRTOS-与-ETH" class="headerlink" title="结合 FreeRTOS 与 ETH"></a>结合 FreeRTOS 与 ETH</h2><p>现在遇到一个很难搞的问题，一个 ETH 测试程序跑得好好的，但一加上 FreeRTOS 的模块就出问题了，不知道怎么搞啊。</p><p>经过不断地观察，发现使用 LwIP 与 FreeRTOS 的示例里，<code>MX_LWIP_Init()</code> 这个初始化函数是在线程里面的，但是我的 ETH 测试程序里，<code>MX_ETH_Init()</code> 是在 main 函数里，os 初始化和开始之前的。于是试着将这个函数的调用移到 default 线程中……然后就可以了。但是，这到底是为什么呢？难道说 RTOS 的初始化和开始的过程会对 ETH 或者 DMA 模块有影响吗？还是说，是内存地址的原因呢。RTOS 确实是会对内存进行管理的。</p><p>接着就还有一个问题，就是在 free 内存的时候会报错。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ETH_RxCpltCallback</span><span class="hljs-params">(ETH_HandleTypeDef * heth)</span>&#123;ETH_BufferTypeDef * pBuff;HAL_StatusTypeDef status;status = HAL_ETH_ReadData(heth, (<span class="hljs-type">void</span>**)&amp;pBuff);<span class="hljs-keyword">if</span> (status != HAL_OK) &#123;Error_Handler();&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Packet Received successfully!\r\n&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received length: %lu&quot;</span>, pBuff-&gt;len);fflush(<span class="hljs-number">0</span>);<span class="hljs-built_in">free</span>(pBuff); <span class="hljs-comment">// 就是这里有问题</span>&#125;</code></pre></div><p>下面是对应的分配内存代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ETH_RxAllocateCallback</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ** buff)</span> &#123; ETH_BufferTypeDef * p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>); <span class="hljs-keyword">if</span> (p) &#123;   * buff = (<span class="hljs-type">uint8_t</span> * ) p + offsetof(ETH_AppBuff, buffer);   p -&gt; next = <span class="hljs-literal">NULL</span>;   p -&gt; len = <span class="hljs-number">100</span>; &#125; <span class="hljs-keyword">else</span> &#123;   * buff = <span class="hljs-literal">NULL</span>; &#125;&#125;</code></pre></div><p>这个问题的话，就试试用 RTOS 提供的内存管理处理一下吧。首先在线程中， ETH 初始化前初始化一个内存池子。</p><div class="code-wrapper"><pre><code class="hljs c">rxBufferPool = osMemoryPoolNew(ETH_RXBUFNB, ETH_RX_BUF_SIZE, <span class="hljs-literal">NULL</span>);assert_param(rxBufferPool != <span class="hljs-literal">NULL</span>);</code></pre></div><p>接着修改分配内存的代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ETH_RxAllocateCallback</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ** buff)</span> &#123;ETH_AppBuff * pAppBuff = osMemoryPoolAlloc(rxBufferPool, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 这里使用了 os 的线程安全内存分配方法</span><span class="hljs-keyword">if</span> (pAppBuff) &#123;ETH_BufferTypeDef * p = &amp;(pAppBuff-&gt;AppBuff);*buff = pAppBuff-&gt;buffer;p-&gt;next = <span class="hljs-literal">NULL</span>;p-&gt;len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始大小设为 0</span>p-&gt;buffer = *buff; <span class="hljs-comment">// buffer 指针指向实际 buff 位置</span>&#125; <span class="hljs-keyword">else</span> &#123;*buff = <span class="hljs-literal">NULL</span>;&#125;&#125;</code></pre></div><p>然后是接收到数据时的回调函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ETH_RxCpltCallback</span><span class="hljs-params">(ETH_HandleTypeDef * heth)</span>&#123;ETH_BufferTypeDef * pBuff;HAL_StatusTypeDef status;status = HAL_ETH_ReadData(heth, (<span class="hljs-type">void</span>**)&amp;pBuff);<span class="hljs-keyword">if</span> (status != HAL_OK) &#123;Error_Handler();&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Packet Received successfully!\r\n&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received length: %lu&quot;</span>, pBuff-&gt;len);osMemoryPoolFree(rxBufferPool, pBuff);  <span class="hljs-comment">// 这边修改为使用 os 的释放方法</span>fflush(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>将开发板和电脑用网线连接，然后配置一下 IP, 就能使用 Wireshark 抓取到板子发送的 packet 了：</p><p><img src="/2024/11/30/stm32-ethercat/img1.png" alt="Wireshark 上接收到的数据"></p><p><img src="/2024/11/30/stm32-ethercat/img2.png" alt="packet 的内容"></p><p>至此就成功应用了 FreeRTOS 并实现了 ETH 的基本功能。</p><h2 id="成为-Vscode-少女吧"><a href="#成为-Vscode-少女吧" class="headerlink" title="成为 Vscode 少女吧"></a>成为 Vscode 少女吧</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=590252&auto=1&height=66"></iframe><p>终于,我受不了那个鬼 CubeIDE 了，虽然大致还是功能齐全的，但是是不是就卡死要重启，而且更个新还更坏了，用不了了，真是垃圾 eclipse。于是果断改用 vscode，其实官方也已经有了个叫 STM32 VS Code Extension 的拓展，只要按照 user guide 上的做就能顺利迁移了。真是悔不当初啊。不过用这个插件有一个限制，就是它只有 st-link 的选项，如果用 J-Link 或其它下载器不知道能不能用。</p><p>主要的操作就是把一些之前的 IDE 相关的文件删掉，一般只用保留 <code>Driver</code>, <code>Core</code>, <code>Middlewares</code>, <code>*.ioc</code>, <code>.mxproject</code> 这几个文件&#x2F;目录就可以了。然后用 CubeMX 打开 .ioc 文件，IDE 那里选择 Cmake, 然后重新生成代码。在拓展里有一个 <code>import Cmake project</code> 的选项，使用它选择该目录，拓展就会生成一些 <code>.vscode</code> 的文件，这样就实现可以自动补全之类的功能啦！接着如果项目有一些自己添加的源文件和 include 的路径需要在 <code>CmakeLists.txt</code> 里面对应地添加。如下面这样：</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 通过 file 命令匹配多个文件</span><span class="hljs-keyword">file</span>(GLOB SOEM_SOURCES <span class="hljs-string">&quot;Middlewares/Ethercat/osal/*.c&quot;</span> <span class="hljs-string">&quot;Middlewares/Ethercat/oshw/*.c&quot;</span> <span class="hljs-string">&quot;Middlewares/Ethercat/soem/*.c&quot;</span>)<span class="hljs-comment"># Add sources to executable</span><span class="hljs-keyword">target_sources</span>(<span class="hljs-variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> PRIVATE    <span class="hljs-comment"># Add user sources here</span>    <span class="hljs-variable">$&#123;SOEM_SOURCES&#125;</span> <span class="hljs-comment"># 添加匹配的文件</span>    <span class="hljs-string">&quot;Core/Src/oled.c&quot;</span> <span class="hljs-comment"># 直接添加源文件</span>    <span class="hljs-string">&quot;Core/Src/key.c&quot;</span>    <span class="hljs-string">&quot;Core/Src/lan8720.c&quot;</span>    <span class="hljs-string">&quot;Core/Src/SV630N.c&quot;</span>)<span class="hljs-comment"># Add include paths</span><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> PRIVATE    <span class="hljs-comment"># Add user defined include paths</span>    <span class="hljs-string">&quot;Middlewares/Ethercat/osal&quot;</span> <span class="hljs-comment"># 添加包含路径</span>    <span class="hljs-string">&quot;Middlewares/Ethercat/oshw&quot;</span>    <span class="hljs-string">&quot;Middlewares/Ethercat/soem&quot;</span>)</code></pre></div><p>这样之后点击生成应该就可以开始 build 流程了。</p><blockquote><p>如果配置 Cmake 的时候提示缺少 Ninja 的话，需要再安装一个 <a href="https://github.com/ninja-build/ninja">ninja build tool</a><br>点击上面的链接，进入 <a href="https://github.com/ninja-build/ninja/releases">Release 页面</a>，下载对应系统架构的版本，解压文件到一个目录，并把该目录添加进环境变量的 Path 里面（为安全着想，这个目录最好没有其它文件）</p></blockquote><p>build 完之后，在侧边栏找到运行与调试，选择 <code>Build &amp; Debug...</code>，然后点开始调试，就会开始下载程序并调试了（记得把线连上）。如果它提示需要更新 st-link firmware 那就在扩展里点相应的选项即可。如果报错，那就在命令行敲 <code>stlinkupgrade</code>（记得把线连上）。</p><p>接着就可以在 vscode 里愉快地敲代码啦。</p><h2 id="注意-ISR-与-RTOS-的配合"><a href="#注意-ISR-与-RTOS-的配合" class="headerlink" title="注意 ISR 与 RTOS 的配合"></a>注意 ISR 与 RTOS 的配合</h2><p>Debug 途中，遇到一个问题，貌似网络接收不太正常，找了一圈发现是 <code>RxAllocCallback()</code> 函数中使用内存池进行内存分配时出现了问题，代码如下：</p><div class="code-wrapper"><pre><code class="hljs c">ETH_AppBuff* appBuff = osMemoryPoolAlloc(rxMemoryPool, <span class="hljs-number">1000</span>);</code></pre></div><p>调试时发现，这个函数调用前 4 次都正常，但后面就返回 NULL 了，而内存池显然是还有空间的。进入这个函数的源码内看，发现原来是在 ISR 中，它要求 <code>timeout == 0</code>，倒也合情合理。而这个回调函数的前4次是在 HAL_ETH_Start_IT() 中调用的，后面的就是在中断中调用了，所以就出问题了。</p><p>为解决这个问题，我干脆新建两个 ETH 发送和接收的线程，rx 中断仅仅用于释放信号量，线程中则永久等待信号量，这样简化了 ISR，也不要在 ISR 中处理这么多事情了。</p><p>写完，实测，能跑，不错。</p><h2 id="汇川进入-OP-状态时出错"><a href="#汇川进入-OP-状态时出错" class="headerlink" title="汇川进入 OP 状态时出错"></a>汇川进入 OP 状态时出错</h2><p>现在有个棘手的问题，就是汇川驱动器 SV630N，在接收到进入 OP 运行状态的请求时，就会报错 EE09.3, 看文档的话，说的是同步丢失的问题，上网找了一圈也都试过各种方法都不太行。不知道要怎么办了。</p><p><img src="/2024/11/30/stm32-ethercat/img3.png" alt="EE09.3 的错误详细信息"></p><p>在网上寻找的时候发现 SOEM Github 上的<a href="https://github.com/OpenEtherCATsociety/SOEM/issues/487#issuecomment-786245585">一个issue</a>，他说可以检查一下 Register System Time Difference (0x092C:0x092F)，它的值最好是小于 1ms，若满足要求则可以开始 sync0&#x2F;1 信号的生成。</p><blockquote><p>The best way to make sure all slave clocks are locked in is to measure the internal closed loop parameters. Register System Time Difference (0x092C:0x092F) is the obvious one to test. When it’s value drops below one microsecond and stays below it then you have reached reasonable synchronization. It is the task of the application programmer (and not SOEM) to monitor this for all slaves. Only when this constraint is satisfied try to start the sync0&#x2F;1 generation.</p></blockquote><p>有可能要在</p><blockquote><p> Keep in mind that some slaves will take up to 10 seconds or more to measure. Forcing safe-OP to OP before that will cause the slave to fail.</p></blockquote><p>接着提出 issue 的人指出可以尝试在 config mapping 之前配置 DC clock，但我的代码就是这样的呀。</p><blockquote><p>Thank you so much Arthur. Finally after reading your message and many old issues as well I realized that it’s better to configure de DC clock before mapping the slaves (in Pre-OP). I was first mapping the slaves and then configuring the DC clock (I think that I took it from an example). So right now the slaves go to OP without no error at the first attempt!</p></blockquote><blockquote><p>The thing is when you call ec_dcsync0() before ec_configdc() that the latter will overwrite the slave reference clock. If the first sync0 did not trigger before that then it most likely will not trigger for a long time. The reason is that the first sync0 will fire at an absolute time (64bit). So make sure this absolute time is always a bit in the future.</p></blockquote><p>在<a href="https://github.com/OpenEtherCATsociety/SOEM/issues/520">另一篇 issue</a> 中，开发者说明了可能需要在 safe-op 状态下跑一段时间，确认了满足条件后再请求进入 OP 状态，以让驱动器有足够的时间确认 DC 时钟。</p><blockquote><p>The correct timing to start sync0 generation is AFTER slave AND master clock synchronization, but BEFORE going to OP. And, to be sure the slave has time to validate proper master and sync0 timing, wait a few seconds before going to OP. ec_configdc() should be called at pre-OP. Then run the 10.000 cycles, then sync the master clock. There are a few weird slaves out there that require to set-up sync0 on the transition from pre-OP to safe-OP. This is violating the EtherCAT protocol specification but what can you do? It is like “I was programmed without understanding the standards and only tested with TwinCAT and now I am confused and going to crash”.</p></blockquote><p>然后下面是 issue 作者整理的一份执行顺序</p><p>Okay so the order should be:</p><ol><li>Call ec_config_init() to move from INIT to PRE-OP state.</li><li>Do slave-specific configurations via SDO communication</li><li>Set ecx_context.manualstatechange &#x3D; 1. Map PDOs for all slaves by calling ec_config_map().</li><li>Call ec_configdc() in PRE-OP state</li><li>Manually call the transition to SAFE-OP (some slaves require starting sync0 here, but this is a violation of the EtherCAT protocol spec so it is not the default)</li><li>Do 10,000 process data cycles in SAFE-OP state</li><li>Synchronise the slave and master clock by setting the master clock &#x3D; slave reference clock</li><li>Call ec_dcsync0() for the reference clock slave</li><li>Wait for a few seconds</li><li>Transition to OP state</li></ol><p>我觉得可以先试试。</p><p>嗯……试了也不行呐……</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在此姑且用流水账的形式记录一下用 STM32 开发 Ethercat 主站时遇到的重重困难。&lt;/p&gt;
&lt;h2 id=&quot;开发板硬件配置&quot;&gt;&lt;a href=&quot;#开发板硬件配置&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="嵌入式" scheme="https://worranhin.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="https://worranhin.github.io/tags/STM32/"/>
    
    <category term="EtherCAT" scheme="https://worranhin.github.io/tags/EtherCAT/"/>
    
  </entry>
  
  <entry>
    <title>Pip Install Gymnasium[box2d] 失败</title>
    <link href="https://worranhin.github.io/2024/10/17/pip-conda/"/>
    <id>https://worranhin.github.io/2024/10/17/pip-conda/</id>
    <published>2024-10-17T12:17:15.000Z</published>
    <updated>2025-07-08T06:40:16.406Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到个诡异的问题，想试玩一下 <a href="https://gymnasium.farama.org/">gymnasium</a> 的时候按照<a href="https://gymnasium.farama.org/introduction/basic_usage/">指示</a>需要先后安装 swig 和 gymnasium[box2d]。我首先创建了一个 venv 虚拟环境，然后安装 swig 和 gymnasium[box2d]</p><div class="code-wrapper"><pre><code class="hljs shell">pip install swig gymnasium</code></pre></div><p>但是会报如下错误：</p><div class="code-wrapper"><pre><code class="hljs shell">Requirement already satisfied: gymnasium[box2d] in d:\documents\learn\gymnasium\.venv\lib\site-packages (1.0.0)Requirement already satisfied: numpy&gt;=1.21.0 in d:\documents\learn\gymnasium\.venv\lib\site-packages (from gymnasium[box2d]) (2.1.2)Requirement already satisfied: cloudpickle&gt;=1.2.0 in d:\documents\learn\gymnasium\.venv\lib\site-packages (from gymnasium[box2d]) (3.1.0)Requirement already satisfied: typing-extensions&gt;=4.3.0 in d:\documents\learn\gymnasium\.venv\lib\site-packages (from gymnasium[box2d]) (4.12.2)  Requirement already satisfied: farama-notifications&gt;=0.0.1 in d:\documents\learn\gymnasium\.venv\lib\site-packages (from gymnasium[box2d]) (0.0.4)Collecting box2d-py==2.3.5 (from gymnasium[box2d])  Using cached box2d-py-2.3.5.tar.gz (374 kB)  Installing build dependencies ... done    Getting requirements to build wheel ... done  Preparing metadata (pyproject.toml) ... doneCollecting pygame&gt;=2.1.3 (from gymnasium[box2d])  Using cached pygame-2.6.1-cp312-cp312-win_amd64.whl.metadata (13 kB)Requirement already satisfied: swig==4.* in d:\documents\learn\gymnasium\.venv\lib\site-packages (from gymnasium[box2d]) (4.2.1)Using cached pygame-2.6.1-cp312-cp312-win_amd64.whl (10.6 MB)Building wheels for collected packages: box2d-py  Building wheel for box2d-py (pyproject.toml) ... error  error: subprocess-exited-with-error    × Building wheel for box2d-py (pyproject.toml) did not run successfully.  │ exit code: 1  ╰─&gt; [21 lines of output]      Using setuptools (version 75.2.0).      C:\Users\Administrator\AppData\Local\Temp\pip-build-env-f86pf3pa\overlay\Lib\site-packages\setuptools\_distutils\dist.py:261: UserWarning: Unknown distribution option: &#x27;test_suite&#x27;         warnings.warn(msg)      running bdist_wheel      running build      running build_py      creating build\lib.win-amd64-cpython-312\Box2D      copying library\Box2D\Box2D.py -&gt; build\lib.win-amd64-cpython-312\Box2D      copying library\Box2D\__init__.py -&gt; build\lib.win-amd64-cpython-312\Box2D      creating build\lib.win-amd64-cpython-312\Box2D\b2      copying library\Box2D\b2\__init__.py -&gt; build\lib.win-amd64-cpython-312\Box2D\b2      running build_ext      building &#x27;Box2D._Box2D&#x27; extension      swigging Box2D\Box2D.i to Box2D\Box2D_wrap.cpp      swig.exe -python -c++ -IBox2D -small -O -includeall -ignoremissing -w201 -globals b2Globals -outdir library\Box2D -keyword -w511 -D_SWIG_KWARGS -o Box2D\Box2D_wrap.cpp Box2D\Box2D.i      Traceback (most recent call last):        File &quot;&lt;frozen runpy&gt;&quot;, line 198, in _run_module_as_main        File &quot;&lt;frozen runpy&gt;&quot;, line 88, in _run_code        File &quot;D:\Documents\learn\Gymnasium\.venv\Scripts\swig.exe\__main__.py&quot;, line 4, in &lt;module&gt;      ModuleNotFoundError: No module named &#x27;swig&#x27;      error: command &#x27;D:\\Documents\\learn\\Gymnasium\\.venv\\Scripts\\swig.exe&#x27; failed with exit code 1      [end of output]  note: This error originates from a subprocess, and is likely not a problem with pip.  ERROR: Failed building wheel for box2d-pyFailed to build box2d-pyERROR: ERROR: Failed to build installable wheels for some pyproject.toml based projects (box2d-py)</code></pre></div><p>看错误信息应该是找不到 swig 这个包，但确实安装了的。重启终端，再试试，还是不行。于是上网找了好几个方法，都不大行。然后想手动安装 swig 试试，但是下载下来的压缩包也没有 swig.exe 这个文件，明明文档里说会附带的。接着就尝试按指引把程序 build 出来吧，但是也是有问题。着实是有点崩溃。</p><p>最后突然想到用 conda 试试吧， 创了个 python3.11 的 conda 环境，用 conda 进行安装：</p><div class="code-wrapper"><pre><code class="hljs shell">conda install swigconda install gymnasium[box2d]</code></pre></div><p>结果还真行了。真是奇怪呢。</p><blockquote><p>Banner Photo by <a href="https://unsplash.com/@tsuyoshikozu?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">tsuyoshi kozu</a> on <a href="https://unsplash.com/photos/a-bunch-of-white-flowers-with-green-leaves-tzMg6t06zDg?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>  </p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;今天遇到个诡异的问题，想试玩一下 &lt;a href=&quot;https://gymnasium.farama.org/&quot;&gt;gymnasium&lt;/a&gt; 的时候按照&lt;a</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cmake 找不到动态链接库</title>
    <link href="https://worranhin.github.io/2024/09/14/cmake/"/>
    <id>https://worranhin.github.io/2024/09/14/cmake/</id>
    <published>2024-09-14T09:22:49.000Z</published>
    <updated>2025-07-08T06:40:16.406Z</updated>
    
    <content type="html"><![CDATA[<p>近期在写实验程序时需要用到一个厂商给的 SDK，那么在 cmake 里应该就是添加一个 <code>IMPORTED</code> 的动态库，并且配置一些参数就可以了。</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(NTSDK SHARED IMPORTED)<span class="hljs-keyword">set_target_properties</span>(NTSDK PROPERTIES  IMPORTED_IMPLIB <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib64/NTControl.lib&quot;</span>)<span class="hljs-keyword">set_target_properties</span>(NTSDK PROPERTIES  IMPORTED_LOCATION <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib64/NTControl.dll&quot;</span>)</code></pre></div><p>但奇怪的是这段代码在项目根目录中的 CmakeLists.txt 还可以正常生成，但是当我想要将它写入子文件夹后再用 <code>add_subdirectory</code> 添加嵌套的 <code>CmakeLists.txt</code> 后，编译时却发现找不到这个库了。</p><div class="code-wrapper"><pre><code class="hljs gradle">[build] some<span class="hljs-regexp">/path/</span>x86_64-w64-mingw32<span class="hljs-regexp">/bin/</span>ld.exe: cannot <span class="hljs-keyword">find</span> -lNTSDK: No such <span class="hljs-keyword">file</span> or directory</code></pre></div><p>反复试了几次还是不行，于是去翻看<a href="https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries">官方的文档</a>，发现调用实例后面还有个 <code>GLOBAL</code> 选项。仔细一看，这个选项的作用正是令 target name 全局可见！</p><blockquote><p>GLOBAL</p><p>   Make the target name globally visible.</p></blockquote><p>于是在子目录下的 <code>CmakeLists.txt</code> 中的 <code>add_library</code> 加入 <code>GLOBAL</code> 选项，就可以正常运行了。</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(NTSDK SHARED IMPORTED)<span class="hljs-keyword">set_target_properties</span>(NTSDK PROPERTIES  IMPORTED_IMPLIB <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib64/NTControl.lib&quot;</span>)<span class="hljs-keyword">set_target_properties</span>(NTSDK PROPERTIES  IMPORTED_LOCATION <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib64/NTControl.dll&quot;</span>)</code></pre></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;近期在写实验程序时需要用到一个厂商给的 SDK，那么在 cmake 里应该就是添加一个 &lt;code&gt;IMPORTED&lt;/code&gt; 的动态库，并且配置一些参数就可以了。&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vscode Serial Monitor 的显示失误</title>
    <link href="https://worranhin.github.io/2024/05/27/serial-monitor/"/>
    <id>https://worranhin.github.io/2024/05/27/serial-monitor/</id>
    <published>2024-05-27T12:37:03.000Z</published>
    <updated>2025-07-08T06:40:16.406Z</updated>
    
    <content type="html"><![CDATA[<p>今天调试程序的时候遇见一个问题，就是在 Arduino 框架下写的 stm32 串口通讯程序不能发送 0x7f 以上的数值，这有点奇怪。代码如下：</p><div class="code-wrapper"><pre><code class="hljs cpp">Serial.<span class="hljs-built_in">write</span>(<span class="hljs-number">0xff</span>);  <span class="hljs-comment">// （任何大于 0x7f 的数）输出结果为 fffd</span></code></pre></div><p>这其实能看出来有点诡异，因为 0x7f 应该就是 ascii 码的最大值，不能输出比这大的数，感觉是遇到了一些奇怪的机制。在 Bing 中稍微搜索了一下，好像也没看到类似的问题。于是去质问 Perplexity，诶，竟然就真的问出来了。</p><blockquote><p>Based on the provided search results, when sending values greater than 0x7F (127 in decimal) over serial using Serial.write() in Arduino, you may encounter an issue where the values are displayed incorrectly, often as “fffd”, in the serial monitor or terminal.This behavior is not an issue with the Serial.write() function itself, but rather with how the serial monitor or terminal interprets and displays the received bytes.</p></blockquote><p>他说这不是 Arduino 本身的问题，而是串口监视器的问题，他还附上了一个 Github issue 的链接 ( <a href="https://github.com/microsoft/vscode-serial-monitor/issues/139">https://github.com/microsoft/vscode-serial-monitor/issues/139</a> )。这个就是 vscode 串行监视器的仓库，在这个 issue 里就有人提出了一样的问题，也有人给出了一个解决了问题的版本。装上那个版本试了试，确实就可以了。</p><p>这个故事告诉我们，面对一些疑难杂症时，将问题尽可能描述清楚，AI 小助手还真能帮上忙呢。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;今天调试程序的时候遇见一个问题，就是在 Arduino 框架下写的 stm32 串口通讯程序不能发送 0x7f 以上的数值，这有点奇怪。代码如下：&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs</summary>
        
      
    
    
    
    
    <category term="AI" scheme="https://worranhin.github.io/tags/AI/"/>
    
    <category term="工具" scheme="https://worranhin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="嵌入式" scheme="https://worranhin.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="vscode" scheme="https://worranhin.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>LibreTexts</title>
    <link href="https://worranhin.github.io/2024/04/18/LibreText/"/>
    <id>https://worranhin.github.io/2024/04/18/LibreText/</id>
    <published>2024-04-18T08:33:47.000Z</published>
    <updated>2025-07-08T06:40:16.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>过去没学的矩阵分析，现在开始吞噬我</p></blockquote><p>今天在看论文时，陷入了不断压栈的知识回调地狱，直到需要补习伪逆知识的时候，发现了这个网站——<a href="https://math.libretexts.org/">LibreTexts Mathematics</a>。发现这个电子书网站还挺不错的，讲的挺好，覆盖面足够广。点开主页，发现它是一个开放教育资源平台 <a href="https://libretexts.org/">LibreTexts</a> 的一部分。这个平台致力于减少传统教材书籍的花费与限制，让教育资源更具开放性。</p><blockquote><p>LibreTexts is the adaptable, user-friendly open education resource platform that educators trust for creating, customizing, and sharing accessible, interactive textbooks, adaptive homework, and ancillary materials. We collaborate with individuals and organizations to champion open education initiatives, support institutional publishing programs, drive curriculum development projects, and more.</p></blockquote><p><img src="/2024/04/18/LibreText/1.png" alt="LibreTexts 网站首页"></p><p>真是不错呢。<del>封面的姐姐也好美啊</del></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;过去没学的矩阵分析，现在开始吞噬我&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天在看论文时，陷入了不断压栈的知识回调地狱，直到需要补习伪逆知识的时候，发现了这个网站——&lt;a</summary>
        
      
    
    
    
    
    <category term="网站" scheme="https://worranhin.github.io/tags/%E7%BD%91%E7%AB%99/"/>
    
    <category term="电子书" scheme="https://worranhin.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>广州设计三年展</title>
    <link href="https://worranhin.github.io/2024/03/27/GZ-Design/"/>
    <id>https://worranhin.github.io/2024/03/27/GZ-Design/</id>
    <published>2024-03-27T10:09:43.000Z</published>
    <updated>2025-07-08T06:40:16.375Z</updated>
    
    <content type="html"><![CDATA[<p>上周末久违地去了广东美术馆，这次的展出是广州设计三年展。</p><span id="more"></span><p><img src="/2024/03/27/GZ-Design/1.jpg" alt="广州设计三年展"></p><p>在第一层的大多是一些来自世界各地的建筑设计，其中比较有意思的是一个叫泰国杂筑的建筑群（社区），研究者调查了一个位于泰国的杂筑社区，记录了其中的民生百态。</p><p>在它旁边的是一个海边简易小民居，简单的红色篷布盖在简单的竹架上，视觉上却有着不错的效果。</p><p><img src="/2024/03/27/GZ-Design/2.jpg" alt="海边小屋"></p><p>另一个比较有意思的是一个叫褶屋（还是褶房，忘记名字了）的艺术设计，走进其中，如一个迷宫，不知何处可走，哪里是死胡同，再加上柔软而容易深陷其中的地面，给置身其中的人一种梦幻、迷离的感受。当时的第一感受就是“好像在子宫里一样”。</p><p><img src="/2024/03/27/GZ-Design/3.jpg" alt="褶屋"></p><p>下面是一个来自印度的音乐家之屋，是为玩音乐的人而设计的建筑，它比较有特色的是通过有意地调整屋顶的倾斜角度将天窗和观众席巧妙地融合在一起，使得音乐家可以在屋顶表演，而观众可以自然而然地坐在天窗上<del>（屋里的人能感受到来自PP和脚丫的压迫感）</del>。</p><p><img src="/2024/03/27/GZ-Design/4.jpg" alt="音乐家之屋"></p><p>继续走能看到一个巨大的金属建筑，其上被冰冷的钢铁划分为若干格子，温室内放有一些植物。建筑旁边的简介是《温室：诊所》。在这样的温室中接受治疗，是否能让心情更好呢？不过金属的质感与诊所的卫生感相对应，而具有生机的植物与诊所行医之事相对应，这么看来这个建筑与诊所又颇有一番联系。</p><p><img src="/2024/03/27/GZ-Design/5.jpg" alt="温室外景"></p><p><img src="/2024/03/27/GZ-Design/6.jpg" alt="温室内景"></p><p>下面竟然还看到了何镜堂院士的作品，而且就在我华工校内，不知道以后有无机会亲身到访能。它是一个将废弃教授别墅改造为工作室的项目。这个作品其实初看感觉稍显平凡，但也许正是它具有地域性与亲和力才让我产生这种平凡感。</p><p><img src="/2024/03/27/GZ-Design/7.jpg" alt="镜园"></p><p>再往上走就是不限于建筑的更广泛的设计作品了。而下面这三个是关于环保主题的作品。第一个作品名为海洋之椅，是设计师与海洋居民利用海洋垃圾制作而成。第二个作品名为《有冇用》是利用塑料废弃物制作而成的具有瓷器之形的艺术品。这两件作品都试图将大家认为是垃圾的东西做成了或具有功能性或具有装饰性的物品，试图唤起人们的环保意识。第三个是一个研究项目在夏威夷海滩上发现的由沙砾与塑料废物形成的新形态的岩石，他们将其命名为胶砾岩。这不禁让人感慨大自然的力量。</p><p><img src="/2024/03/27/GZ-Design/8.jpg" alt="海洋之椅"><img src="/2024/03/27/GZ-Design/9.jpg" alt="有冇用"><img src="/2024/03/27/GZ-Design/10.jpg" alt="胶砾岩"></p><p>再继续走可以看到一个照片长廊，上面是一些街头摄影作品，记录了街坊的生活点滴。我还挺喜欢这种东西的，有点想在家里也搞一个，把日常拍的值得纪念的东西做成一个照片墙，一定会很有意思。</p><p><img src="/2024/03/27/GZ-Design/11.jpg" alt="照片墙"></p><p>下面这个是将汉字重新拆分组合的设计，这也是我喜欢的事情，觉得挺有意思的，这种思路未来可以用在 logo 设计中。</p><p><img src="/2024/03/27/GZ-Design/12.jpg" alt="拼字"></p><p>接下来这个展台展示了一种 Google 出品的为视障人士设计的盲文输入法。试图解决盲人用虚拟键盘输入不方便的问题，就是不知道实际用户体验如何。</p><p><img src="/2024/03/27/GZ-Design/15.jpg" alt="盲文键盘"></p><p>后面还看到了一个粤语研究，可以说是全场最好玩的了，充分展示了粤语的可扩展性与灵活性。</p><p><img src="/2024/03/27/GZ-Design/16.jpg" alt="粤语研究"></p><p>然后差不多就这样结束了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周末久违地去了广东美术馆，这次的展出是广州设计三年展。&lt;/p&gt;</summary>
    
    
    
    
    <category term="逛展" scheme="https://worranhin.github.io/tags/%E9%80%9B%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Vscode-Cpp</title>
    <link href="https://worranhin.github.io/2024/01/18/vscode-cpp/"/>
    <id>https://worranhin.github.io/2024/01/18/vscode-cpp/</id>
    <published>2024-01-18T06:24:08.000Z</published>
    <updated>2025-07-08T06:40:16.375Z</updated>
    
    <content type="html"><![CDATA[<p>今天在实验室的新电脑上又遇到了 vscode 的 c&#x2F;c++ 没有类型提示的问题。记得之前也遇过几次这个问题，但不记得怎么解决了。搞了一上午，终于解决了，现在有必要记录一下，以免下次又遇到这个鬼问题。</p><p>一开始想到的就是<strong>重装</strong>，重装扩展，重装 vscode，再把 <code>.code</code> 文件删掉，把 <code>settings.json</code> 的目录也删掉，都还是解决不了问题。</p><p>搞了一圈，发现问题应该主要就是没有编译器环境。回到扩展页面看<a href="https://code.visualstudio.com/docs/cpp/config-msvc">这个 MSVC 的教程</a> ，按它说的装好了，却还是有问题。选也选不了。于是又试了试 <a href="https://code.visualstudio.com/docs/cpp/config-mingw">Mingw 的这个教程</a> ，这下终于正常了，正常地报错了，报的是头文件的错，说是 <code>#include errors detected. Please update your includePath.</code>，这个倒简单了，<a href="https://zhuanlan.zhihu.com/p/616798432">上网一搜</a>就知道去哪找 <code>includePath</code> 了。但更新完 <code>includePath</code> 后还是有点问题，<code>include</code> 了头文件，正文里的东西还是报错，但编译却没问题。于是打开 <code>configuration UI</code> 更改 <code>Compiler Path</code> 为 gcc 就好了。</p><p><img src="/2024/01/18/vscode-cpp/ScreenShot.jpg" alt="Compiler Path 截图"></p><p>说起来这么简单的东西竟然搞了这么久，难受。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;今天在实验室的新电脑上又遇到了 vscode 的 c&amp;#x2F;c++</summary>
        
      
    
    
    
    
    <category term="工具" scheme="https://worranhin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vscode" scheme="https://worranhin.github.io/tags/vscode/"/>
    
    <category term="cpp" scheme="https://worranhin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>实用小工具</title>
    <link href="https://worranhin.github.io/2023/09/22/newPC/"/>
    <id>https://worranhin.github.io/2023/09/22/newPC/</id>
    <published>2023-09-22T07:17:43.000Z</published>
    <updated>2025-07-08T06:40:16.375Z</updated>
    
    <content type="html"><![CDATA[<p>最近实验室这边配了台新电脑，刚上手时还挺不习惯，陆续下载了一些实用的小工具后，才渐渐改造成自己习惯的样子。其中有一些小软件，开始还不记得名字，还得翻看自己的电脑才知道。所以在这里记录下这一类对我而言挺有用但不太记得名字的实用小软件。</p><span id="more"></span><h2 id="EarTrumpet"><a href="#EarTrumpet" class="headerlink" title="EarTrumpet"></a>EarTrumpet</h2><blockquote><p><a href="https://eartrumpet.app/">https://eartrumpet.app/</a></p></blockquote><p>EarTrumpet 是一个音量控制小工具，它以托盘形式存在于任务栏上，可以方便地更改各个程序的音量大小，属于是原生音量控制的增强版。</p><p><img src="https://eartrumpet.app/hero.gif" alt="EarTrumpet 界面"></p><h2 id="TranslucentTB"><a href="#TranslucentTB" class="headerlink" title="TranslucentTB"></a>TranslucentTB</h2><blockquote><p><a href="https://github.com/TranslucentTB/TranslucentTB">https://github.com/TranslucentTB/TranslucentTB</a></p></blockquote><p>这是一个桌面美化的工具，可以让 Windows 的任务栏变得完全透明，同时也有磨砂效果等其它选项。</p><p><img src="https://camo.githubusercontent.com/4a55c49eab17e22feb137f52efdb78f930365b7b56eb365ac769d20eb6508089/68747470733a2f2f692e696d6775722e636f6d2f654c47547477702e706e67" alt="TransllucentTB 效果"></p><h2 id="Twinkle-Tray"><a href="#Twinkle-Tray" class="headerlink" title="Twinkle Tray"></a>Twinkle Tray</h2><blockquote><p><a href="https://twinkletray.com/">https://twinkletray.com/</a></p></blockquote><p>Twinkle Tray 是一个屏幕亮度调节的工具，与 EarTrumpet 类似，以托盘形式存在，它可以让用户像笔记本电脑一样在系统里调节屏幕的亮度。此外，如果有多个屏幕，也可以在一个地方控制多个屏幕的亮度。</p><p><img src="https://twinkletray.com/assets/img/tt-comparison.jpg" alt="Twinkle Tray 界面"></p><h2 id="Pomotroid"><a href="#Pomotroid" class="headerlink" title="Pomotroid"></a>Pomotroid</h2><blockquote><p><a href="https://splode.github.io/pomotroid/">https://splode.github.io/pomotroid/</a></p></blockquote><p>Pomotroid 是一个开源、简洁的番茄钟应用，没有太多复杂的功能，很符合我的审美。</p><p><img src="https://splode.github.io/pomotroid/pomotroid-screens.png" alt="Pomotroid 界面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近实验室这边配了台新电脑，刚上手时还挺不习惯，陆续下载了一些实用的小工具后，才渐渐改造成自己习惯的样子。其中有一些小软件，开始还不记得名字，还得翻看自己的电脑才知道。所以在这里记录下这一类对我而言挺有用但不太记得名字的实用小软件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://worranhin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>汕头之旅🚗</title>
    <link href="https://worranhin.github.io/2023/06/27/ShanTou/"/>
    <id>https://worranhin.github.io/2023/06/27/ShanTou/</id>
    <published>2023-06-27T08:08:36.000Z</published>
    <updated>2025-07-08T06:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1407540299&auto=0&height=66"></iframe><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><p>在毕业离校之前，和同学一起去汕头来一次自驾游。从广州出发，开往汕头，四百多公里，将近五个小时，好在车上的人都是司机，轮着开也不会太辛苦。（事实上只有两个人轮着开高速）。路上还可以欣赏沿途的风景。</p><!-- more --><p><img src="/2023/06/27/ShanTou/falls.jpg" alt="沿途上看到的瀑布"></p><p><img src="/2023/06/27/ShanTou/bridge.jpg" alt="金潮大桥"></p><p>（天气也是非常晴朗呢）</p><h2 id="第一天——逛逛市区"><a href="#第一天——逛逛市区" class="headerlink" title="第一天——逛逛市区"></a>第一天——逛逛市区</h2><h3 id="到达汕头"><a href="#到达汕头" class="headerlink" title="到达汕头"></a>到达汕头</h3><p>到达汕头后已经是中午了，我们先去到了本地同学老陈的家里稍加整顿，然后出去他家附近吃午饭——牛肉粿条。</p><p><img src="/2023/06/27/ShanTou/teow.jpg" alt="料很足的牛肉粿条"></p><p>吃饱后顺便打包一份去接即将到达汕头站的同学。至此我们凑够了一车五个人。</p><p>接着我们驱车前往市区，找了个地方歇脚，还顺便买了点喝的东西和一些小零食。</p><h3 id="下午逛市区"><a href="#下午逛市区" class="headerlink" title="下午逛市区"></a>下午逛市区</h3><p>稍作休息，我们去到一个步行街逛了逛。</p><p><img src="/2023/06/27/ShanTou/street.jpg" alt="步行街"></p><p>在步行街附近，找了家店吃了点水粿、无米粿和绿豆汤等作为下午茶。</p><p><img src="/2023/06/27/ShanTou/ChweeKueh.jpg" alt="甜甜的水粿"></p><p><img src="/2023/06/27/ShanTou/hau-a-koe.jpg" alt="韭菜馅的无米粿"></p><p><img src="/2023/06/27/ShanTou/soup.jpg" alt="清清凉凉的绿豆汤等"></p><p>在炎炎夏日中，清清凉凉的绿豆汤无疑是全场最佳。绿豆汤整体是甜的，但和广州的绿豆糖水不同，这里的绿豆并不会煮得很烂，而是保持一颗颗的状态，而且用的也是去皮的绿豆，这样的结果是绿豆汤会很清澈，喝起来很解渴，非常不错。</p><p>下午茶过后，下午就快要结束了，于是我们回去老陈家附近的一个酒店落脚并收拾行囊。</p><h3 id="晚餐——牛肉火锅"><a href="#晚餐——牛肉火锅" class="headerlink" title="晚餐——牛肉火锅"></a>晚餐——牛肉火锅</h3><p>晚上，我们和老陈的家人一起共进晚餐，吃的是大名鼎鼎的潮汕牛肉火锅。</p><p><img src="/2023/06/27/ShanTou/beef.jpg" alt="满满的一碟牛肉"></p><p>这样大碟的牛肉有两碟，可想而知我们这晚吃得有多饱。</p><h3 id="晚上的东海岸"><a href="#晚上的东海岸" class="headerlink" title="晚上的东海岸"></a>晚上的东海岸</h3><p>吃得这么饱，当然要出去散散步消化一下，于是我们去到汕头的东海岸，散步。</p><p>海岸边的海风挺大的，吹到人的身上也挺舒服的。</p><p>海岸的下面是海滩，海滩上堆了很多人造物，<a href="https://www.zhihu.com/question/21098231">搜了搜</a>发现这些东西叫护面块体，用于防浪和阻止舰船登录用的。</p><p>在海边翻翻石头还能看到一些小蟹，也有很多在海边赶海的人。</p><p><img src="/2023/06/27/ShanTou/crab.jpg" alt="小小的蟹"></p><p><img src="/2023/06/27/ShanTou/comber.jpg" alt="赶海人的收获"></p><p>回去的时候试了试打开天窗，把头伸出窗外，让海风猛烈地吹过我的身躯，这感觉实在非常舒爽，让我充分感受到了伸出窗外的狗头的快乐。</p><p><img src="/2023/06/27/ShanTou/dog.jpg" alt="伸出车窗外的狗头" title="就是这个感觉（图由 AI 生成）"></p><p>回去经过城区的时候还买了草莓冰和甘草水果，真的是肚子收获满满的一天。</p><p>等回到酒店已经快 12 点了，就洗洗睡了。</p><h2 id="第二天——南澳岛🏖"><a href="#第二天——南澳岛🏖" class="headerlink" title="第二天——南澳岛🏖"></a>第二天——南澳岛🏖</h2><p>第二天的早上，老陈带我们去吃了汕头特色的肠粉，这里的肠粉里面也有很多料，像是用肠粉皮包着许多馅料的食物，馅料包括豆芽、小蚝等海边的东西，表面还有撒了一些菜圃，对早餐来说实在是太多了。</p><p><img src="/2023/06/27/ShanTou/SVR.jpg" alt="汕头肠粉"></p><p>吃好早餐，我们启程前往南澳岛，耗时约一个小时。</p><p><img src="/2023/06/27/ShanTou/onBridge.jpg" alt="南澳大桥上的风光"></p><p>南澳桥的通行费为 90 块钱，包含往返两程。过了南澳大桥就是南澳岛啦。</p><p>南澳岛的主路基本就是沿着岛的周围而建的，而岛的中间是山，鲜有人烟。岛上的居民也大多靠海建设村庄。</p><p><img src="/2023/06/27/ShanTou/motor.jpg" alt="岛上骑摩托的酷姐姐"></p><p>在这之前，我们订了岛上的一间民宿，但这时还没到入住时间，于是我们绕岛逆时针而行，前往北回归线广场看看。</p><h3 id="北回归线广场"><a href="#北回归线广场" class="headerlink" title="北回归线广场"></a>北回归线广场</h3><p>北回归线广场上有一个大大的人造物，其上有一个球状物，球状物上有一个孔，据说在夏至的正午时分，太阳的光线就会通过这个孔照到地上。巧的是我们去的那天还正好是夏至日。所以那里也聚集了一大堆人，所以想一看究竟是<em>很难的啦</em>。</p><p><img src="/2023/06/27/ShanTou/ball.jpg" alt="北回归线的大球"></p><p>通过这个大球的另一边是一片大海，<del>海的那边是……</del>是一望无际的大海。海边的风很大，比前一天在内陆东海岸的风大得多。（可以听听下面的视频稍微感受一下）</p><p><video src="./wave.mp4" controls>您的浏览器不支持 HTML5 视频。</video></p><h3 id="中午的海鲜大餐"><a href="#中午的海鲜大餐" class="headerlink" title="中午的海鲜大餐"></a>中午的海鲜大餐</h3><p>晃一晃又到了中午吃饭时间，这次去的是老陈同学推荐的海鲜餐厅，这里比较有意思的是他是先让客人报预算价钱，然后他会帮忙选菜式再让我们确认。他们的出品也是非常的不错。其中最有趣的是白灼鱿鱼，吃得每个人的嘴都是黑的。😂</p><p>其次就是花甲（花蛤），非常的鲜甜，肉质饱满，是我的最爱😋。虾和鱼也很不错。还有第一次吃的海瓜子，不过这东西软软的，不太符合我的口味。据说这个东西在这边常被当做零食吃。</p><p><img src="/2023/06/27/ShanTou/squid.jpg" alt="白灼鱿鱼"></p><p><img src="/2023/06/27/ShanTou/ManilaClam.jpg" alt="花甲"></p><p><img src="/2023/06/27/ShanTou/clam.jpg" alt="海瓜子"></p><h3 id="入住海景民宿"><a href="#入住海景民宿" class="headerlink" title="入住海景民宿"></a>入住海景民宿</h3><p>吃完饭后，我们前往预订的民宿入住，这个民宿比预期要好很多，可以说是远超预期，客厅和房间都很大，甚至还有麻将桌。海景也是真的海景，非常不错。</p><p><img src="/2023/06/27/ShanTou/oceanRoom.jpg" alt="海景房的海景"></p><h3 id="与海浪共舞"><a href="#与海浪共舞" class="headerlink" title="与海浪共舞"></a>与海浪共舞</h3><p>民宿的楼下就是一片可供游客游玩的海滩，所以在下午休息片刻后，我们就换上泳衣前往海滩游玩。这里的海浪也非常的大，非等闲之辈可以驾驭得住，随着夜晚的靠近，海浪也随之愈发的增强。但在这海边可不缺弄潮儿，在那远处，能隐约看到缓缓游动的大叔。而我等凡人只能在靠近岸边的地方被海浪掀翻，不得不产生对大海的敬畏之情。</p><p><img src="/2023/06/27/ShanTou/wave.jpg" alt="下午的海浪"></p><h3 id="夜游海岛"><a href="#夜游海岛" class="headerlink" title="夜游海岛"></a>夜游海岛</h3><p>从海滩回来，洗了洗澡，就又到了觅食的时间了。</p><p>本打算去一家老陈以前去过的烧烤店吃烧烤的，但奈何那旁边的小河散发着大家难以忍受的恶臭，所以不得不改地方了。不过这里也没有白来，这家店还有炒冰吃，我们点了几份炒冰先填着肚子。话说炒冰这东西也是好久没吃过了，这家炒冰也是做得挺不错的。尽管环境的恶化让他们的烧烤生意冷淡，但他们家的炒冰也是挺多人来买的。</p><p><img src="/2023/06/27/ShanTou/ice.jpg" alt="炒冰"></p><p>吃着炒冰，大家来到一家海产店买了点手信。然后去到一个长堤坝边上。这时老陈就开始整活了，他告诉我们有个地方有绳子可以爬上去堤坝上。于是秉持着探索精神，我们沿着堤坝走着，还真的找到了个绳子。于是大家也就纷纷爬了上去。但上去后纷纷表示被骗了。窄窄的堤坝，下面是还算高的海滩，海滩上堆了很多护面块体，这一看就不是一般人会下去的，可能也只有赶海的人会下去摸鱼吧。但上面的风倒是挺大的，大到大家都不敢站起来，脚趾紧紧扣着拖鞋，如果掉下去，应该也很难捞上来了。坐了一会，我们就下来了。</p><p><img src="/2023/06/27/ShanTou/dam.jpg" alt="堤坝上的风景"></p><p><img src="/2023/06/27/ShanTou/climb.jpg" alt="爬堤坝的老陈"></p><h3 id="真正的烧烤"><a href="#真正的烧烤" class="headerlink" title="真正的烧烤"></a>真正的烧烤</h3><p>从堤坝下来后找了家挺多好评的烧烤摊，出发。</p><p>烧烤嘛，也不用多说了，挺好吃的。</p><p><img src="/2023/06/27/ShanTou/BBQ.jpg" alt="烧烤的一部分"></p><p>吃完烧烤，回到住的地方，玩了会麻将，这天就结束 nya~</p><h2 id="第三天——重回市区"><a href="#第三天——重回市区" class="headerlink" title="第三天——重回市区"></a>第三天——重回市区</h2><p>前一天玩得比较晚，这一天也起的比较晚，合情合理。</p><h3 id="最后的南澳时光"><a href="#最后的南澳时光" class="headerlink" title="最后的南澳时光"></a>最后的南澳时光</h3><p>于是我们买了点面包，就启程回去了。回去当然也不是原路返回。我们来的时候都只走了南半岛，那么回去的时候就继续逆时针地沿岛绕回去吧。这途中也能遇见一些好风景呢。</p><p><img src="/2023/06/27/ShanTou/lighthouse.jpg" alt="灯塔"></p><p><img src="/2023/06/27/ShanTou/float.jpg" alt="布满浮筒的大海"></p><p><img src="/2023/06/27/ShanTou/NanAoBridge.jpg" alt="南澳大桥" title="再见南澳"></p><h3 id="回到市区"><a href="#回到市区" class="headerlink" title="回到市区"></a>回到市区</h3><p>回到市区我们吃了卤水火锅。</p><p><img src="/2023/06/27/ShanTou/hotpot.jpg" alt="卤水火锅"></p><p>之后大家都觉得下午太热了，于是又躲到一家台球馆里避暑。就这样又到了傍晚时分。</p><p>从台球馆出来，我们前往了江边吹风。</p><h3 id="江边吹晚风"><a href="#江边吹晚风" class="headerlink" title="江边吹晚风"></a>江边吹晚风</h3><p>其实开始并非只是来吹风，而是想坐一坐这里的轮渡，然后过对岸看看。但是这天正值端午节，实在是太多人了，所以在江边吹吹风好了。</p><p><img src="/2023/06/27/ShanTou/boat.jpg" alt="挤满人的船"></p><p>走过来的时候还顺便尝了尝这里的豆花和草粿。这里的豆花比广州那边的豆腐花要浓稠好多，非常顶饱。而草粿则感觉像是以前吃过的味道，不过依稀记得以前吃的是绿绿的，而这里的草粿则是像龟苓膏和凉粉一样是黑黑的，不过口感却和龟苓膏和凉粉都不同。</p><p><img src="/2023/06/27/ShanTou/douhua.jpg" alt="豆花"></p><p>吹完风，我们到附近的一家薏米粥去吃一顿（相对）简单的晚餐。</p><p>晚饭后在城里兜了一下，又尝了尝这里的绿豆饼、风吹饼和糖葱薄饼。本来还想试试蚝烙的，但是几家店都没开门，没办法，只能回去了。</p><p>因为计划下一天早上回广州，所以这晚就早点休息了，毕竟还要开长途车呢。</p><h2 id="第四天——返航"><a href="#第四天——返航" class="headerlink" title="第四天——返航"></a>第四天——返航</h2><p>早上吃了早餐就开车回去广州了。在汕头的最后一餐吃的是粿条，里面有虾、有蚝还有猪杂，很不错的一餐，可谓相见恨晚呐。</p><p><img src="/2023/06/27/ShanTou/riceNoodles.jpg" alt="粿条" title="汕头的最后一餐"></p><p>吃了几次粿条，感觉跟广州这边的河粉还挺像的。希望回到广州也能吃到这么丰富的粿条。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>快乐的旅行时间总是过得这么快，这次虽然只在汕头玩，但感觉完全没玩够呢，蚝烙还没吃着就得离开了。更何况还有潮州、揭阳、汕尾都没去过呢（倒是经过了）（不过据说汕尾不算潮汕地区？）。一言以蔽之，潮汕地区是个值得再来的地方🥰。</p><style>  video {    width: 720px;    max-width: 90%;    margin: 0 auto;    display: block;    border-radius: 5px;    box-shadow: 0px 5px 10px rgba(0,0,0,0.2);  }</style>]]></content>
    
    
    <summary type="html">在毕业之际，和同学去汕头来一场自驾游吧！</summary>
    
    
    
    
    <category term="游记" scheme="https://worranhin.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>人与智能</title>
    <link href="https://worranhin.github.io/2023/04/29/chatbot/"/>
    <id>https://worranhin.github.io/2023/04/29/chatbot/</id>
    <published>2023-04-29T16:41:33.000Z</published>
    <updated>2025-07-08T06:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>突然想到，有了像 chatGPT 这样的技术，是否可以做到让 AI 学习一个人的说话方式，并模仿他说话呢？想到这里，我又不禁联想到《克拉拉与太阳》里面，乔西的家人试图让克拉拉学习模仿乔西的行为，以便在乔西离世后代替她的陪伴。此外，在今年春节上映的电影《流浪地球2》中也提到了数字生命的概念，电影中的人物试图通过计算机模拟他在车祸中失去的女儿。在动画剧集《万神殿》中也有一个称为“上传智能” (Uploaded Intelligence) 的概念，这里是通过将人类的大脑破坏性扫描并上传到计算机中，从而摆脱身体遭受的疾病。</p><p>上述作品都涉及到了 AI 在人类情感上的应用，他们都或多或少地希望 AI 能够复现他们失去的亲人。而现代技术的发展又让这样的科幻场景离我们越来越近，随之而来的可能是一些关于人的哲学思考。</p><p>不管怎样，还是非常好奇，期待这样的技术能继续发展下去，我相信上述场景应该不用多久就可以看到了吧。真想看看到时人们是怎么探讨这些哲学问题的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;突然想到，有了像 chatGPT 这样的技术，是否可以做到让 AI</summary>
        
      
    
    
    
    
    <category term="AI" scheme="https://worranhin.github.io/tags/AI/"/>
    
    <category term="杂想" scheme="https://worranhin.github.io/tags/%E6%9D%82%E6%83%B3/"/>
    
    <category term="chatGPT" scheme="https://worranhin.github.io/tags/chatGPT/"/>
    
    <category term="科幻" scheme="https://worranhin.github.io/tags/%E7%A7%91%E5%B9%BB/"/>
    
  </entry>
  
  <entry>
    <title>技术更迭</title>
    <link href="https://worranhin.github.io/2023/04/10/GPT/"/>
    <id>https://worranhin.github.io/2023/04/10/GPT/</id>
    <published>2023-04-10T11:19:18.000Z</published>
    <updated>2025-07-08T06:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>突然想起来，之前 NFT、数字货币的热度都被 chatGPT 等 AI 技术冲淡了。现在技术发展的速度还真是快啊。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;突然想起来，之前 NFT、数字货币的热度都被 chatGPT 等 AI</summary>
        
      
    
    
    
    
    <category term="杂想" scheme="https://worranhin.github.io/tags/%E6%9D%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Alter Framework</title>
    <link href="https://worranhin.github.io/2023/04/08/alter-framework/"/>
    <id>https://worranhin.github.io/2023/04/08/alter-framework/</id>
    <published>2023-04-08T07:42:09.000Z</published>
    <updated>2025-07-08T06:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>将博客的框架从 Jekyll 更换为 Hexo 了。🤗</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;将博客的框架从 Jekyll 更换为 Hexo</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>春天的落叶</title>
    <link href="https://worranhin.github.io/2023/04/05/Leaf/"/>
    <id>https://worranhin.github.io/2023/04/05/Leaf/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2025-07-08T06:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>树叶从枝头脱离，<br>缓缓飘落，<br>有的落在冰冷的水泥地上，<br>有的落在湿润的泥土地中。  </p><span id="more"></span><p>从高空中落下的雨滴，<br>飘荡在空中的水汽，<br>她们陪在落叶身旁，<br>让他不会因孤独而感伤。  </p><p>泥地中的落叶在朋友们的陪伴下，投入泥土的怀抱，<br>身体慢慢瓦解，<br>灵魂回到树梢。  </p><p>水泥地上的落叶在一脚又一脚的踩踏下，与大地紧靠，<br>在天气变得干爽后，他将得以摆脱地面的束缚，随风飘去，<br>又或者，在这之前，被好心的人捡起，送往未知的地方。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;树叶从枝头脱离，&lt;br&gt;缓缓飘落，&lt;br&gt;有的落在冰冷的水泥地上，&lt;br&gt;有的落在湿润的泥土地中。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="诗" scheme="https://worranhin.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
</feed>
