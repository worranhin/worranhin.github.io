<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GPT</title>
    <link href="/2023/04/10/GPT/"/>
    <url>/2023/04/10/GPT/</url>
    
    <content type="html"><![CDATA[<p>突然想起来，之前 NFT、数字货币的热度都被 chatGPT 等 AI 技术冲淡了。现在技术发展的速度还真是快啊。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Alter Framework</title>
    <link href="/2023/04/08/alter-framework/"/>
    <url>/2023/04/08/alter-framework/</url>
    
    <content type="html"><![CDATA[<p>将博客的框架从 Jekyll 更换为 Hexo 了。🤗</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>春天的落叶</title>
    <link href="/2023/04/05/Leaf/"/>
    <url>/2023/04/05/Leaf/</url>
    
    <content type="html"><![CDATA[<p>树叶从枝头脱离，<br>缓缓飘落，<br>有的落在冰冷的水泥地上，<br>有的落在湿润的泥土地中。  </p><p>从高空中落下的雨滴，<br>飘荡在空中的水汽，<br>她们陪在落叶身旁，<br>让他不会因孤独而感伤。  </p><p>泥地中的落叶在朋友们的陪伴下，投入泥土的怀抱，<br>身体慢慢瓦解，<br>灵魂回到树梢。  </p><p>水泥地上的落叶在一脚又一脚的踩踏下，与大地紧靠，<br>在天气变得干爽后，他将得以摆脱地面的束缚，随风飘去，<br>又或者，在这之前，被好心的人捡起，送往未知的地方。</p>]]></content>
    
    
    
    <tags>
      
      <tag>诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空循环与 Volatile | 嵌入式</title>
    <link href="/2023/03/13/debug/"/>
    <url>/2023/03/13/debug/</url>
    
    <content type="html"><![CDATA[<p>今天下午啊，在帮老陈同学调试它的小屏幕程序代码。有段程序他在调试时可以运行，但直接编译下载到板子上就不能运行。通过<em>控制变量法</em>，我们可以知道应该是调试程序和编译程序存在某些不同。再看问题代码，是一段等待硬件响应的空循环。看到这里，我忍不住地向空循环中加了句 <code>delay</code> 延时。果然，加了后就能跑了。这时不禁联想到之前微机课设时看到的编译器用户手册中说道，对于一些奇怪的代码，编译器是会进行优化的。于是，把编译器的优化选项关掉，就可以成功运行了。查看配置后也发现，调试时是会阻止一些会影响调试的编译优化。</p><p>但是问题没这么简单，编译器怎会连这些基本的东西都没考虑到呢？出于好奇，把优化后的汇编程序弄出来看了看，其循环部分的<strong>大意</strong>如下所示：</p><div class="code-wrapper"><pre><code class="hljs ASM">WHILE_LOOP:CMP R3, #1BNE WHILE_LOOP</code></pre></div><p>好家伙它根本没重新读取值就比较，那不就死循环了吗！这时结合对优化的记忆再查阅 <em>ARMCC 手册</em>，可以发现它在讲 <code>volatile</code> 时提到了类似的例子。再看 <code>while</code> 循环里的条件判断，是一个判断外设变量的值，再进去看，果然这个库里的外设变量没有用 <code>volatile</code> 修饰。加上 <code>volatile</code>，开启编译器优化，上传程序，能跑。问题解决啦。到头来，还是代码不规范的问题呀，编译器是有考虑到这种情况的。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>代码规范真的很重要，按规范写代码可以省心不少。之前还看到一个新闻，一个人因为代码不规范被同事枪杀了，所以为了自己与他人的生命安全，同志们在写代码时一定要按规范行事。多看看编译器等的官方文档、User Guide 还是有帮助的。</p><p>顺便在这里摘录一些从 <em>ARMCC User Guide</em> 上看到的编程原则吧：</p><h3 id="循环编写"><a href="#循环编写" class="headerlink" title="循环编写"></a>循环编写</h3><p>写循环时尽可能做到：  </p><ul><li>使用简单的终止条件</li><li>编写倒数到 0 的循环 (count-down-to-zero loops)</li><li>使用 <code>unsigned int</code> 类型的计数器</li><li>测试与 0 相等 (test for equality against zero)</li></ul><h3 id="使用-volatile"><a href="#使用-volatile" class="headerlink" title="使用 volatile"></a>使用 volatile</h3><p>以下情况需要用 <code>volatile</code>：  </p><ul><li>访问内存映射的外设 (Accessing memory-mapped peripherals)</li><li>多线程共享全局变量</li><li>在中断或信号处理程序中访问全局变量</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>碎屏手机的数据迁移</title>
    <link href="/2023/03/12/broken-screen/"/>
    <url>/2023/03/12/broken-screen/</url>
    
    <content type="html"><![CDATA[<p>最近发生一件令人心碎的事情，我妈妈的手机屏幕碎掉了！！（嗯……心碎好像有点夸张了，但反正不是好事。）</p><img src="/2023/03/12/broken-screen/broken-screen.jpg" class="" width="200" height="300"><p>屏幕的问题好解决，换手机就可以。但是数据需要迁移到新手机。迁移数据可以使用手机常用的迁移助手。但这时问题来了，使用迁移助手需要在旧手机上操作，但屏幕的触控已经坏了，该怎么操作呢？</p><p>这时当然需要在互联网上寻求解决方案，而一个 <a href="https://www.bilibili.com/video/BV16Y411a7zC/?share_source=copy_web&vd_source=2feca964be8cfa9b36e6a01530ba1e60">B 站的视频</a>给了我灵感。既然屏幕按不了，那可以接<strong>鼠标</strong>操作呀！</p><p>就这样借助鼠标再通过一些技巧，成功地在旧手机上下载迁移助手并完成数据迁移。</p><blockquote><p>如果实在半个屏幕摸不到，可以借助手机自带的<strong>无障碍模式</strong>进行辅助。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>现在的数据真是非常的重要，平时一定要做好备份哪！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jekyll 中改变图片尺寸</title>
    <link href="/2023/03/12/resize-image/"/>
    <url>/2023/03/12/resize-image/</url>
    
    <content type="html"><![CDATA[<p>在写博客时有时因为图片太大，想要改变图片的大小，但是又不想嵌入 <em>html</em>。于是上网查了一下，很快啊，就有解决方法了。</p><p><a href="https://www.seanosier.com/2021/03/19/resize-images-in-jekyll-markdown/#:~:text=To%20resize%20an%20image%20in%20Jekyll%20Markdown%20without,Go%20in%20the%20Curly%20Braces%2C%20After%20the%20%3A">这篇文章</a>说到，只要在图片后添加 <code>&#123;:&#125;</code> 即可。示例如下：</p><div class="code-wrapper"><pre><code class="hljs arduino">![image](path/to/image.png)&#123;:width=<span class="hljs-string">&quot;50%&quot;</span>&#125;![image](path/to/image.png)&#123;:width=<span class="hljs-string">&quot;100px&quot;</span> height=<span class="hljs-string">&quot;200px&quot;</span>&#125;</code></pre></div><hr><blockquote><p>2023-04-08 更新</p></blockquote><p>Hexo 不支持这个语法，我的天哪！🥹</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Edge | 拆分窗口功能</title>
    <link href="/2023/03/04/edge/"/>
    <url>/2023/03/04/edge/</url>
    
    <content type="html"><![CDATA[<p>今天新发现 Edge(dev) 的一个新功能（也可能更新了很久但我没有发现而已），它可以在一个窗口内分割成两个页面。</p><p><img src="/2023/03/04/edge/menu.png" alt="右键菜单"></p><p>如上图所示，只要右键点击一个链接，就会有 <em>在拆分窗口中打开链接</em> 的选项。单击它就会出现如下界面。</p><p><img src="/2023/03/04/edge/split-window.png" alt="拆分窗口预览"></p><p>可见，窗口被拆成两个，可以同时浏览。这对于只有一个屏幕但想要对照着看一些网页的用户还是比较有帮助的。</p><p>此外，这个窗口可以被随意拖动以调整大小。</p><p><img src="/2023/03/04/edge/split-window-demo.gif" alt="调整拆分窗口大小预览"></p><p>对于打开了拆分窗口的标签页样式，会稍有不同：</p><p><img src="/2023/03/04/edge/tab.png" alt="拆分窗口标签页对比"></p><p>右上角弹出的三个按钮可以对拆分标签页进行操作：</p><p><img src="/2023/03/04/edge/close-btn.png" alt="拆分窗口操作按钮"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个功能还是不错的，可以比较方便地对照着看两个页面，或者从一个网站目录中预览其中的一些网站，而不用频繁地切换标签页。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手柄驱动与游戏冲突问题解决方案</title>
    <link href="/2022/10/15/game-fix/"/>
    <url>/2022/10/15/game-fix/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在用 xbox 手柄玩游戏时偶尔会遇到“手柄操作残影”问题。什么意思呢，就是连上手柄后进入游戏，手柄出于不明原因无法控制游戏。</p><p>如果只是这样，它还不能被称为残影，更可恶的是，游戏中的画面会往一个方向不停移动，就像是手柄上的某个摇杆被一直按在某个方向一样，如下图所示。</p><p><img src="/2022/10/15/game-fix/xcom_error.gif" alt="xcom2 中的错误示例"></p><p>这样子根本就没办法正常的游玩游戏了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决问题，试图在网上搜索。发现是游戏手柄的驱动问题。要解决这个问题，可以在 Windows 上的设备管理器中先禁用掉手柄的驱动，再进入游戏就可以了。如果还想用手柄玩的话，可以将驱动卸载掉，再重新配对连接手柄就可能可以正常了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Game</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git: 让分支 a 忽略分支 B 删除文件的操作</title>
    <link href="/2022/04/13/merge-stuff/"/>
    <url>/2022/04/13/merge-stuff/</url>
    
    <content type="html"><![CDATA[<p>在 git 的使用中，有时会遇到一种情况——在一个长期分支 a 中含有某个文件，而在另一个长期分支 b 中却没有。在之后只有 a 会从 b 合并修改。最好的方法当然是从 b 中新建一些 a 该有的文件，但如果一开始只有 a ，而不得不通过删除操作产生 b 呢？考虑下面一种情况：</p><p>a 分支有 foo.md, no_in_b.md 两个文件，而在 b 分支中不想要 no_in_b.md。我们不得不在 b 分支中删除 no_in_b.md 并提交。这时执行 <code>git log</code> 会有删除 not_in_b.md 的记录。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git log --pretty=onelinec6e8aa93da45da5129aafe78bd99772af39df8e4 (HEAD -&gt; b) delete not_in_b.md4162012db692750ec018679c7a3bd868e8a311f5 (a) add foo.md and not_in_b.md</code></pre></div><p>这时我想要在 b 中修改 foo.md。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git log --pretty=onelinee5c57fbbd8625cf120af1612a9de5c8482c9a6af (HEAD -&gt; b) do some changec6e8aa93da45da5129aafe78bd99772af39df8e4 delete not_in_b.md4162012db692750ec018679c7a3bd868e8a311f5 (a) add foo.md and not_in_b.md</code></pre></div><p>然后合并至 a 中。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git checkout aSwitched to branch &#x27;a&#x27;PS D:\Documents\merge-ours-demo&gt; git merge bUpdating 4162012..e5c57fbFast-forward foo.md      | 3 ++- not_in_b.md | 1 - 2 files changed, 2 insertions(+), 2 deletions(-) delete mode 100644 not_in_b.md</code></pre></div><p>not_in_b.md 被不出意外地删除了，但我并不想这样。先回退至 merge 之前吧。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git reset --hard HEAD^^HEAD is now at 4162012 add foo.md and not_in_b.md</code></pre></div><p>找找 b 删除 not_in_b.md 的一次 commit。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git checkout bSwitched to branch &#x27;b&#x27;PS D:\Documents\merge-ours-demo&gt; git log --pretty=onelinee5c57fbbd8625cf120af1612a9de5c8482c9a6af (HEAD -&gt; b) do some changec6e8aa93da45da5129aafe78bd99772af39df8e4 delete not_in_b.md4162012db692750ec018679c7a3bd868e8a311f5 (a) add foo.md and not_in_b.md</code></pre></div><p>可以看到我们就是在 c6e8aa93 的提交中删除了 not_in_b.md。让我们回到 a 分支中先假装合并这次 commit。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git checkout aSwitched to branch &#x27;a&#x27;PS D:\Documents\merge-ours-demo&gt; git merge -s ours c6e8aa93Merge made by the &#x27;ours&#x27; strategy.</code></pre></div><p>好了现在我们已经假装合并了删除 not_in_b.md 的commit。让我们检查一下 not_in_b.md 还在不在。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; dir    目录: D:\Documents\merge-ours-demoMode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2022/4/13     21:08             12 foo.md-a----         2022/4/13     21:07             40 not_in_b.md</code></pre></div><p>可以看到我们的 not_in_b.md 还在这里。有意思哦~ 再 log 一下我们的记录。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git log --pretty=oneline9da6a2f428ac42ccf54d7fc513e93c0112dbbcb2 (HEAD -&gt; a) Merge commit &#x27;c6e8aa93&#x27; into ac6e8aa93da45da5129aafe78bd99772af39df8e4 delete not_in_b.md4162012db692750ec018679c7a3bd868e8a311f5 (a) add foo.md and not_in_b.md</code></pre></div><p>发现在 delete not_in_b.md 之上多了个 merge 的记录。</p><p>然后再合并我们真正想要的 b 中作出的修改。</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; git merge bMerge made by the &#x27;recursive&#x27; strategy. foo.md | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)</code></pre></div><p>成功合并了。再检查一下 not_in_b.md 还在吗？</p><div class="code-wrapper"><pre><code class="hljs shell">PS D:\Documents\merge-ours-demo&gt; dir    目录: D:\Documents\merge-ours-demoMode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2022/4/13     21:17             29 foo.md-a----         2022/4/13     21:07             40 not_in_b.md</code></pre></div><p>还在！这发生了什么？让我们 log 一下看看。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">PS D:\Documents\<span class="hljs-built_in">merge</span>-ours-demo&gt; git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline</span>b2fc4fc90f7e19bbf8dc1c155bd944068311df00 (HEAD -&gt; <span class="hljs-keyword">a</span>) Merge branch <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span><span class="hljs-number">9</span>da6a2f428ac42ccf54d7fc513e93c0112dbbcb2 Merge commit <span class="hljs-string">&#x27;c6e8aa93&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span>e5c57fbbd8625cf120af1612a9de5c8482c9a6af (b) <span class="hljs-built_in">do</span> some changec6e8aa93da45da5129aafe78bd99772af39df8e4 <span class="hljs-built_in">delete</span> not_in_b.md<span class="hljs-number">4162012</span>db692750ec018679c7a3bd868e8a311f5 (<span class="hljs-keyword">a</span>) <span class="hljs-built_in">add</span> foo.md <span class="hljs-keyword">and</span> not_in_b.md</code></pre></div><p>跟合并前对比发现在 delete not_in_b.md 后追加了我们想要的 do some change。最顶上多了个 merge 的记录。</p><p>其实奥秘就在这条语句中 <code>git merge -s ours c6e8aa93</code>。这条语句会做一次假的合并，它会记录提交，而并不在意合入的分支，只会将当前分支的内容当作合并结果。</p><p>更详细的介绍可以参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6#_%E6%88%91%E4%BB%AC%E7%9A%84%E6%88%96%E4%BB%96%E4%BB%AC%E7%9A%84%E5%81%8F%E5%A5%BD">git book 的这篇教程</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在传热学中应用 AI 的一次失败尝试</title>
    <link href="/2021/12/04/try-ai/"/>
    <url>/2021/12/04/try-ai/</url>
    
    <content type="html"><![CDATA[<p>最近在学传热学和深度学习，传热学的计算要查表查公式，总要翻来翻去的，表中没有的还要插值算，特别麻烦。于是突发奇想，能不能通过机器学习帮我查表呢，于是就有了以下尝试。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 试图用深度学习来查传热学的热物理性质表</span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#先从书上抄几个数据</span>t = [-<span class="hljs-number">50</span>, -<span class="hljs-number">40</span>, -<span class="hljs-number">30</span>, -<span class="hljs-number">20</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]Pr = [<span class="hljs-number">0.728</span>, <span class="hljs-number">0.728</span>, <span class="hljs-number">0.723</span>, <span class="hljs-number">0.716</span>, <span class="hljs-number">0.712</span>, <span class="hljs-number">0.707</span>, <span class="hljs-number">0.705</span>, <span class="hljs-number">0.703</span>, <span class="hljs-number">0.701</span>, <span class="hljs-number">0.699</span>, <span class="hljs-number">0.698</span>]t = np.array(t)Pr = np.array(Pr)<span class="hljs-built_in">print</span>(t.shape)<span class="hljs-built_in">print</span>(Pr.shape)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">(11,)(11,)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> models<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> layers<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> optimizers<span class="hljs-comment">#建立模型</span>model = models.Sequential()model.add(layers.Dense(<span class="hljs-number">2</span>, input_shape=[<span class="hljs-number">1</span>]))model.add(layers.Dense(<span class="hljs-number">1</span>))model.<span class="hljs-built_in">compile</span>(optimizer=optimizers.Adam(<span class="hljs-number">0.05</span>),             loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<span class="hljs-comment">#开始训练</span>history = model.fit(t,                   Pr,                   epochs=<span class="hljs-number">100</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">Epoch 1/1001/1 [==============================] - 0s 999us/step - loss: 511.6551Epoch 2/1001/1 [==============================] - 0s 1000us/step - loss: 349.5498Epoch 3/1001/1 [==============================] - 0s 997us/step - loss: 229.3371...Epoch 97/1001/1 [==============================] - 0s 996us/step - loss: 0.0033Epoch 98/1001/1 [==============================] - 0s 0s/step - loss: 0.0035Epoch 99/1001/1 [==============================] - 0s 997us/step - loss: 0.0036Epoch 100/1001/1 [==============================] - 0s 998us/step - loss: 0.0035</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">test_t = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">120</span>, <span class="hljs-number">140</span>, <span class="hljs-number">160</span>, <span class="hljs-number">180</span>, <span class="hljs-number">200</span>])test_Pr = np.array([<span class="hljs-number">0.688</span>, <span class="hljs-number">0.686</span>, <span class="hljs-number">0.684</span>, <span class="hljs-number">0.682</span>, <span class="hljs-number">0.681</span>, <span class="hljs-number">0.680</span>])<span class="hljs-comment">#验证成果</span>results = model.evaluate(test_t, test_Pr)<span class="hljs-built_in">print</span>(model.predict(test))<span class="hljs-built_in">print</span>(results)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">1/1 [==============================] - 0s 1ms/step - loss: 0.0661[[0.86143714] [0.8761781 ] [0.89091855] [0.905659  ] [0.92040044]]0.06614607572555542</code></pre></div><p>貌似误差有点大呢。我觉得应该有如下原因：</p><ol><li>数据太少，或者说简直是微不足道呀，但是哪里能搞到数据呢，我可不想一个个输入。</li><li>模型的损失函数和优化器之类的选的不对，但我也没学到这里</li><li>层数太少，这个倒是可以试一试</li></ol><div class="code-wrapper"><pre><code class="hljs python">model2 = models.Sequential()model2.add(layers.Dense(<span class="hljs-number">1</span>, input_shape=[<span class="hljs-number">1</span>]))model2.add(layers.Dense(<span class="hljs-number">1</span>))model2.add(layers.Dense(<span class="hljs-number">1</span>))model2.add(layers.Dense(<span class="hljs-number">1</span>))model2.<span class="hljs-built_in">compile</span>(optimizer=optimizers.Adam(<span class="hljs-number">0.05</span>),             loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<span class="hljs-comment">#开始训练</span>history = model2.fit(t,                   Pr,                   epochs=<span class="hljs-number">15</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">Epoch 1/151/1 [==============================] - 0s 1000us/step - loss: 427.6249Epoch 2/151/1 [==============================] - 0s 997us/step - loss: 215.8827Epoch 3/151/1 [==============================] - 0s 997us/step - loss: 97.7123...Epoch 13/151/1 [==============================] - 0s 0s/step - loss: 18.5277Epoch 14/151/1 [==============================] - 0s 998us/step - loss: 18.8840Epoch 15/151/1 [==============================] - 0s 1000us/step - loss: 18.5095</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">results2 = model2.evaluate(test_t, test_Pr)<span class="hljs-built_in">print</span>(model2.predict(test))<span class="hljs-built_in">print</span>(results)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">1/1 [==============================] - 0s 997us/step - loss: 412.5994[[13.871796] [15.194722] [16.517649] [17.840576] [19.163502]]0.06614607572555542</code></pre></div><p>嗯……更离谱了，为什么它的预测是递增的呢，不是很明显是递减的吗……</p><p>不玩了，接着学吧，二者都才刚入门呢。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook 导出 Pdf 不显示中文的解决方案</title>
    <link href="/2021/11/23/jpynb-to-pdf/"/>
    <url>/2021/11/23/jpynb-to-pdf/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我需要把 jupyter notebook 的内容导出为 pdf 格式时，非常欣喜地发现菜单里有熟悉的 pdf 。</p><p><img src="/2021/11/23/jpynb-to-pdf/menu.png" alt="菜单"></p><p>然而，下载后发现中文全都显示不出来。</p><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>上网一搜，轻松地发现了<a href="https://www.jianshu.com/p/6b84a9631f8a">这个方法</a>。概括地说，就是先下载 LaTex 文件（如果没装 LaTex ，还要先安装 <a href="https://miktex.org/download">MiKTex</a> 工具），然后再开头<code>\documentclass[11pt]&#123;article&#125;</code> 的后面加上如下代码：</p><div class="code-wrapper"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;fontspec, xunicode, xltxtra&#125;<span class="hljs-keyword">\setmainfont</span>&#123;Microsoft YaHei&#125;<span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;`</code></pre></div><p>然后再渲染出 pdf 文件。麻烦吗？我也觉得。主要是每次都要改。</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>我经过一番摸索，又发现了另一个较为简单的方法。在刚刚导出 pdf 的菜单里有个 Print Preview 。点一下它，会出现另一个适合打印的输出页面，这时候在浏览器的菜单中找到打印的选项，出现如下界面：</p><p><img src="/2021/11/23/jpynb-to-pdf/print.png" alt="打印界面"></p><p>在右侧选择 Microsoft Print to PDF ，就能保存pdf 文件了。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>下面是两种方案的输出效果对比。</p><p><img src="/2021/11/23/jpynb-to-pdf/solu1.png" alt="方案一效果"></p><p><img src="/2021/11/23/jpynb-to-pdf/solu2.png" alt="方案二效果"></p><p>可以看出方案一输出的结果会更好看，而方案二则是比较方便，实际应用时可以按需选择。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>拍合照的新思路</title>
    <link href="/2021/10/14/photograph/"/>
    <url>/2021/10/14/photograph/</url>
    
    <content type="html"><![CDATA[<p>今天去看展，拿到了一些小卡片，其中一张引起我的注意。</p><p><img src="/2021/10/14/photograph/card.jpg" alt="赠送的小卡片"></p><p>与以往的经验及所见所闻不同，一般的合照都让人群挤在一起，以尽可能地把所有人都包括在照片中，<br>但这样一来就显得十分拥挤，也经常不可避免地会有人的脸被挡住。但这张照片却把镜头拉远了，<br>同时让人物站得比较分散，这样一来，整个画面的构图变得稳定，人物也不拥挤，反而有一种简洁的感觉。<br>与此同时，这张照片中的主角很明显是两位老人家，也就是说摄影师通过远近关系来确定了画面的主次，真的太妙了！<br>而且照片展示了人物的全身，这样人物就能通过肢体语言更好地表现自己的个性。也让照片的内容变得多样而丰富，实在太有趣了！</p><p><img src="/2021/10/14/photograph/hezhao.jpg" alt="放大的照片"></p><p>不过不可否认的是，这张照片的人物也的确较少，人多起来可能也会比较难搞吧。但这的确可以作为今后拍合照时可以考虑的一种思路。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>吹风有感</title>
    <link href="/2021/10/11/wind/"/>
    <url>/2021/10/11/wind/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=376635&auto=1&height=66"></iframe><p>晚风从我身边吹过，在我身上的毛发间穿梭，拨弄着与其相连的神经。<br>与此同时，风还携带着一丝柔和的寒意，刺激着皮肤上的温度传感器。它并非寒冬那种令人发颤的寒风，<br>亦非春日那种潮湿黏糊的回南风，更不是夏天那种携带着暑气的热风，而是秋天的干爽的能带走疲倦与烦恼的快哉风。</p><p>它的一次次穿行活化了我的感官。<br>因他，我的心情变得愉悦，大脑变得清醒，思维变得活跃。让人想一动不动地躺在一望无际的旷野，<br>让她在我的身上轻拢慢捻抹复挑，让我动用全身的传感器去记录每一个令人愉悦的参数，去感受这沁心之风。</p><p>也许一年之中只有这一天，但这就是我心中定义的最美的秋天。</p><hr><p class="footer">    2021年10月11日<br>中国广东省广州市天河区五山街华南理工大学<br>吹风有感</p><style>    .footer{        text-align: end;    }</style>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>看电影 | 你的名字</title>
    <link href="/2021/10/04/your-name/"/>
    <url>/2021/10/04/your-name/</url>
    
    <content type="html"><![CDATA[<p>昨天在 B 站上发现 <a href="https://www.bilibili.com/bangumi/media/md12044"><em>《你的名字》</em></a> 竟然能免费看，实在大为震撼，于是点进去看了看，于是一不小心就又熬夜了😅……</p><span id="more"></span><p><img src="/2021/10/04/your-name/2.webp" alt="你的名字海报"></p><h2 id="算是……影评吗？？"><a href="#算是……影评吗？？" class="headerlink" title="算是……影评吗？？"></a>算是……影评吗？？</h2><p>这是 2016 年的电影了，主要讲的是一个乡村女孩和一个都市男孩互换身体并穿越时空拯救小镇的故事，这么说还挺离奇的，不过艺术嘛……没必要太追究这些啦。这部动画电影给我的第一感觉是“<strong>好美啊！</strong>”，宁静的村落，繁华的都市，还有辽阔的星空，以及贯穿全片的彗星，这一切的场景都令人赏心悦目。  </p><p><img src="/2021/10/04/your-name/1.png" alt="电影截图"></p><p>电影的节奏也把握的很好，前半段通过一些异样的线索把互换身体的现象交代出来，没有过多地解释原因，只知道这是发生在一位女生和一位男生身上的神秘现象。性别互换当然会发生一些有趣的事情，也会让身边的人感到困扰，所以他们在几次交换之后用写日记的方式与对方沟通，并且约法三章。不过尽管如此，两个完全不同，又完全没见过面的人又怎么能完美地扮演成对方呢？（嗯……其实见过一面）</p><p>这不禁让我感慨，人类的多样性是多么美妙的事情呀，大自然的鬼斧神工实在令人敬佩！而我之所以是我，是取决于我的躯壳还是我的灵魂呢，如果我跟别人互换了身体，那么我是跟随着我的躯壳还是依附于我的灵魂，或者说二者都不再是我了呢？恐怕只有等未来科学理论的发展才能给我答案……</p><p>电影的后半部分，停止交换身体的男主人公逐渐发现，那位与自己互换身体的女生竟然是生活在三年前的，而她生活的村庄其实已经毁于三年前的一颗分离的彗星了，她也未能幸免于难。而且关于她的记忆也在悄悄地消失，就连记录在手机上的日记也消失不见了。</p><p>如果我遇到这样的情况，恐怕会觉得自己肯定得了精神病了，一切她存在过的证明都没有了，有的只是残留的模糊的记忆，甚至连她的名字都已忘记，这也太痛苦了吧。所以这一段看得我好憋屈呀！</p><p>然后就是我们的主角们成功改写了过去，在几年后也成功的相见了。（不过这种寻寻觅觅、偶然相遇的桥段真是令人难受）</p><p>奇怪，我怎么会想写下这么一篇观后感呢……也许是被片中失忆的桥段触动了吧，我的记忆中有好多好多美好的事情，好多想想就开心的回忆，如果哪天它们都被清除了，那该多痛苦呀。不巧的是现实中还真有这样的可能，只要遭受小小的意外就可能失忆了，就算不发生意外，许多记忆也正慢慢地变得模糊，直至消失。值得庆幸的是，我的记忆中消极的部分应该是优先被抹除的，因为我好像没什么不好的回忆，毕竟不好的东西也没有记忆的价值嘛😁。所以我要不要考虑把记忆找个地方储存起来呢。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，这部电影很好看，我要给⭐⭐⭐⭐⭐</p><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>说起来，国庆假期也过了一半了，作业还没做完呢（其实回家后就没做过作业），幸好在学校做了一部分才回来，倒是把电影看了，js 也学了一点，了解了一下 <em>matter.js</em> 。真的是学习我不行，不务正业第一名呐。接下来要做作业和复习了。</p><h3 id="回顾一下我的计划吧"><a href="#回顾一下我的计划吧" class="headerlink" title="回顾一下我的计划吧"></a>回顾一下我的计划吧</h3><ul><li><input checked="" disabled="" type="checkbox"> 看一部电影</li><li><input checked="" disabled="" type="checkbox"> 学一学 javascript</li><li><input disabled="" type="checkbox"> 做作业（好多啊） 😭</li><li><input disabled="" type="checkbox"> 复习工程材料（回来要小测） 😫</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>🎉国庆快乐🎉</title>
    <link href="/2021/09/30/national-day/"/>
    <url>/2021/09/30/national-day/</url>
    
    <content type="html"><![CDATA[<p>一年一度的国庆节又到了，今年难得有7天假期（啊啊啊，可恶的疫情，把理所应当的假期变得难得了），我可要好好规划规划。let me see, 我要干的事有：</p><ul><li><input disabled="" type="checkbox"> 看一部电影</li><li><input disabled="" type="checkbox"> 学一学 javascript</li><li><input disabled="" type="checkbox"> 做作业（好多啊） 😭</li><li><input disabled="" type="checkbox"> 复习工程材料（回来要小测） 😫</li></ul><p>如果还有时间就装饰一下我的 <em>灵质空间</em> 吧，about 页好像还没改呢……</p><p><em><strong>节日快乐！</strong></em></p><hr><p>By the way, 我刚刚整理了机械原理已学内容，也 post 上来了，其实这也是建立本空间的初衷之一……这个以后再说吧，我脑子里其实还有更大胆的想法，留个悬念，困了，睡了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机械原理</title>
    <link href="/2021/09/30/machine-theory/"/>
    <url>/2021/09/30/machine-theory/</url>
    
    <content type="html"><![CDATA[<p>机械原理研究的对象是机械，研究的内容是有关机械的基本理论。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><strong>机械</strong>是<strong>机器</strong>和<strong>机构</strong>的总称。</li><li><strong>机构</strong>是用来传递与变换运动和力的可动装置。</li><li><strong>机器</strong>是根据某种使用要求而设计的用来变换或传递能量、物料和信息的执行机械运动的装置。</li></ul><h2 id="机构的结构分析"><a href="#机构的结构分析" class="headerlink" title="机构的结构分析"></a>机构的结构分析</h2><p>机构由以下两部分组成：</p><ol><li>构件：机器中的每个独立运动单元</li><li>运动副：两构件直接接触而组成的可动连接</li></ol><h3 id="自由度"><a href="#自由度" class="headerlink" title="自由度"></a>自由度</h3><h4 id="构件的自由度"><a href="#构件的自由度" class="headerlink" title="构件的自由度"></a>构件的自由度</h4><p>构件在空间中有6个相对自由度，当形成运动副后，将受到约束。</p><blockquote><p>自由度以 $f$ 表示；<br>约束度以 $s$ 表示。<br>两者的关系为：$f&#x3D;6-s$</p></blockquote><h4 id="机构的自由度"><a href="#机构的自由度" class="headerlink" title="机构的自由度"></a>机构的自由度</h4><p>机构自由度的计算公式为：<br>$$F&#x3D;3n-(2p_l+p_h)$$</p><blockquote><p>式中 $n$ 为自由构件数， $p_l$ 为低副数， $p_h$ 为高副数</p></blockquote><h4 id="计算自由度时的注意事项"><a href="#计算自由度时的注意事项" class="headerlink" title="计算自由度时的注意事项"></a>计算自由度时的注意事项</h4><ol><li>复合铰链：m 个构件有 (m-1) 个转动副。</li><li>重复约束只能算一个。</li><li>多处公法线不重合的平面高副构成复合高副，相当于一个低副。</li><li>去除局部约束度</li><li>除去虚约束</li></ol><h3 id="运动副的分类"><a href="#运动副的分类" class="headerlink" title="运动副的分类"></a>运动副的分类</h3><ul><li>运动副按<em>约束度</em>可分为5类——约束度为1的称为I级副(class I pairs)，以此类推。</li><li>按<em>接触情况</em>可分为：<ul><li>高副：单一点或线接触（平面约束度为1）</li><li>低副：面接触（平面约束度为2）</li></ul></li><li>按<em>相对运动种类</em>分为：<ul><li>转动副 (revolute pair)</li><li>移动副 (prismatic pair)</li><li>螺旋副 (helical pair)</li><li>球面副 (spherical)</li></ul></li></ul><h3 id="运动链"><a href="#运动链" class="headerlink" title="运动链"></a>运动链</h3><p>构件通过运动副的连接而构成的可相对运动的系统称为<strong>运动链</strong></p><p>运动链可分为：</p><ul><li>闭式运动链（闭链）</li><li>开式运动链（开链）</li></ul><p>将<strong>运动链</strong>中的某一构件固定为机架即得一<strong>机构</strong>。<br>此时，<strong>机构</strong>由<strong>机架</strong>、<strong>原动件</strong>和<strong>从动件</strong>组成。</p><h3 id="机构运动简图"><a href="#机构运动简图" class="headerlink" title="机构运动简图"></a>机构运动简图</h3><p>机构运动简图是对机构进行分析的重要工具。绘制机构运动简图需要按一定比例尺定出各运动副的位置，并将各运动副及构件用一定的符号表示出来。</p><h3 id="机构具有确定运动的条件"><a href="#机构具有确定运动的条件" class="headerlink" title="机构具有确定运动的条件"></a>机构具有确定运动的条件</h3><p>机构具有确定运动的条件是原动件数目等于机构的自由度数目。</p><h3 id="基本杆组"><a href="#基本杆组" class="headerlink" title="基本杆组"></a>基本杆组</h3><p>最简单的自由度为零的构件称为基本杆组（阿苏尔杆组）。</p><p>基本杆组分为：</p><ul><li>Ⅱ 级组：2 构件 + 3高副</li><li>Ⅲ 级组：4 构件 + 6高副</li></ul><p>遇到低副怎么办？ <strong>高副低代</strong> ！<br>一般转换为转动副</p><h2 id="机构的运动分析"><a href="#机构的运动分析" class="headerlink" title="机构的运动分析"></a>机构的运动分析</h2><p>分析方法有图解法和解析法。</p><h3 id="一般图解法的步骤"><a href="#一般图解法的步骤" class="headerlink" title="一般图解法的步骤"></a>一般图解法的步骤</h3><ol><li>列速度或加速度的矢量方程</li><li>按比例画出已知矢量</li><li>根据矢量合成原理作图求解<blockquote><p>注意：相对运动别忘了科氏加速度</p></blockquote></li></ol><h3 id="速度瞬心法"><a href="#速度瞬心法" class="headerlink" title="速度瞬心法"></a>速度瞬心法</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>找瞬心</li><li>根据两构件瞬心速度相等的关系列方程求解</li></ol><h4 id="瞬心确定方法"><a href="#瞬心确定方法" class="headerlink" title="瞬心确定方法"></a>瞬心确定方法</h4><ul><li>转动副的瞬心在转动副中心</li><li>移动副的瞬心在垂直导路方向的无穷远处</li><li>纯滚动的瞬心在接触点处</li><li>相对滑动的瞬心在过接触点高副元素的公法线上</li><li>三心定理：三构件瞬心在同一直线</li></ul><h2 id="力分析"><a href="#力分析" class="headerlink" title="力分析"></a>力分析</h2><h3 id="移动副摩擦力"><a href="#移动副摩擦力" class="headerlink" title="移动副摩擦力"></a>移动副摩擦力</h3><p>摩擦角：<br>$$\varphi &#x3D; \arctan f$$</p><p>拧紧螺母的平衡力矩：<br>$$M&#x3D;Fd_2&#x2F;2&#x3D;Gd_2\tan (\alpha + \varphi )&#x2F;2$$<br>放松螺母的平衡力矩：<br>$$M&#x3D;Gd_2\tan (\alpha - \varphi )&#x2F;2$$  </p><h3 id="转动副的摩擦力"><a href="#转动副的摩擦力" class="headerlink" title="转动副的摩擦力"></a>转动副的摩擦力</h3><p>摩擦圆：<br>总反力始终相切于摩擦圆。<br>半径 $\rho &#x3D;f_Vr$</p><blockquote><p>$f_V&#x3D;kf (k&#x3D;1 \sim \pi &#x2F;2)$ 是当量摩擦系数。</p></blockquote><h2 id="机械效率"><a href="#机械效率" class="headerlink" title="机械效率"></a>机械效率</h2><ul><li><strong>机械效率</strong> $\eta$ ：机械的输出功与输入功之比。<br>  $$\eta &#x3D; W_r&#x2F;W_d&#x3D;F_0&#x2F;F &#x3D; M_0&#x2F;M$$<blockquote><p>$F_0$是理想驱动力</p></blockquote></li><li><strong>损失率</strong>：损失功与输入功之比。</li></ul><h3 id="机器的机械效率"><a href="#机器的机械效率" class="headerlink" title="机器的机械效率"></a>机器的机械效率</h3><ol><li>串联<br> $$\eta &#x3D; \eta_1 \eta_2 \dots \eta_k$$</li><li>并联<br> $$\eta&#x3D; \frac{P_1\eta_1+P_2\eta_2+\dots+P_k\eta_k}{P_1+P_2+\dots+P_k }$$</li></ol><h2 id="自锁条件"><a href="#自锁条件" class="headerlink" title="自锁条件"></a>自锁条件</h2><ul><li>驱动力在摩擦角内</li><li>单力作用在摩擦圆内</li><li>驱动力任意增大时 $G\le 0$<blockquote><p>$G$为生产阻抗力</p></blockquote></li><li>驱动力任意增大时有$\eta\le 0$</li></ul><hr><p>未完待续……</p><hr><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><table><thead><tr><th align="center">中文 ch</th><th align="center">英文 en</th></tr></thead><tbody><tr><td align="center">机械</td><td align="center">machinery</td></tr><tr><td align="center">机器</td><td align="center">machine</td></tr><tr><td align="center">机构</td><td align="center">mechanism</td></tr><tr><td align="center">总反力</td><td align="center">total reaction</td></tr><tr><td align="center">摩擦角</td><td align="center">angle of friction</td></tr><tr><td align="center">理想驱动力</td><td align="center">ideal driving force</td></tr><tr><td align="center">机械原理</td><td align="center">theory of machines and mechanisms</td></tr><tr><td align="center">自由度</td><td align="center">degree of freedom</td></tr><tr><td align="center">约束度</td><td align="center">degree of constraint</td></tr><tr><td align="center">转动副</td><td align="center">revolute pair</td></tr><tr><td align="center">移动副</td><td align="center">prismatic pair</td></tr><tr><td align="center">螺旋副</td><td align="center">helical pair</td></tr><tr><td align="center">球面副</td><td align="center">spherical</td></tr><tr><td align="center">闭式运动链</td><td align="center">closed kinematic chain</td></tr><tr><td align="center">开式运动链</td><td align="center">open kinematic chain</td></tr><tr><td align="center">机架</td><td align="center">ixed link</td></tr><tr><td align="center">原动件</td><td align="center">driving link</td></tr><tr><td align="center">从动件</td><td align="center">drived link</td></tr><tr><td align="center">运动链</td><td align="center">kinematic chain</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>站名予定</title>
    <link href="/2021/09/29/change-name/"/>
    <url>/2021/09/29/change-name/</url>
    
    <content type="html"><![CDATA[<p>我苦思冥想终于想到一个绝妙而又符合主题的名字—— <strong>Hin’s 灵质空间</strong>！😆  </p><p>灵质空间这东西，不了解的人可能还不了解，了解的人应该会比较了解，不了解但想了解的人可以在<a href="https://www.bilibili.com/bangumi/media/md1733/">这里</a>了解了解。😝</p><p>嘿嘿，不卖关子了，其实灵质空间这个概念出自一部国产动漫—— <em><a href="https://www.bilibili.com/bangumi/media/md1733/">罗小黑战记</a></em> ,想详细了解的可以自行搜索。它的其中一个特性是空间的主人相当于空间的神明，哈哈哈哈哈，那不就是我吗！</p><hr><p>就这样，站名已确定，我也该睡了……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>部署成功</title>
    <link href="/2021/09/29/deploy-successfully/"/>
    <url>/2021/09/29/deploy-successfully/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉"><a href="#🎉" class="headerlink" title="🎉"></a>🎉</h1><p>网站已经成功在 github pages 上部署啦！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开站大吉</title>
    <link href="/2021/09/29/my-first-try/"/>
    <url>/2021/09/29/my-first-try/</url>
    
    <content type="html"><![CDATA[<h1 id="初"><a href="#初" class="headerlink" title="初"></a>初</h1><p>这是我的第一篇文章，如果我有恒心且在之后都还记得它的话，本站会变得越来越丰满，敬请期待吧！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
